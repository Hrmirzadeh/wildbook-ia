{"parents": [{"link": "../../../", "title": "Module code"}, {"link": "../../", "title": "ibeis"}], "title": "ibeis.scripts.name_recitifer", "body": "<h1>Source code for ibeis.scripts.name_recitifer</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"c1\"># -*- coding: utf-8 -*-</span>\n<span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"k\">import</span> <span class=\"n\">absolute_import</span><span class=\"p\">,</span> <span class=\"n\">division</span><span class=\"p\">,</span> <span class=\"n\">print_function</span><span class=\"p\">,</span> <span class=\"n\">unicode_literals</span>\n<span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>\n\n\n<div class=\"viewcode-block\" id=\"reasign_names1\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.reasign_names1\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">reasign_names1</span><span class=\"p\">(</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">aid_list</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">old_img2_names</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">common_prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Changes the names in the IA-database to correspond to an older</span>\n<span class=\"sd\">    naming convention.  If splits and merges were preformed tries to</span>\n<span class=\"sd\">    find the maximally consistent renaming scheme.</span>\n\n<span class=\"sd\">    Notes:</span>\n<span class=\"sd\">        For each annotation:</span>\n<span class=\"sd\">        * get the image</span>\n<span class=\"sd\">        * get the image full path</span>\n<span class=\"sd\">        * strip the full path down to the file name prefix:</span>\n<span class=\"sd\">             [ example /foo/bar/pic.jpg -&gt; pic ]</span>\n<span class=\"sd\">        * make the name of the individual associated with that annotation be the</span>\n<span class=\"sd\">          file name prefix</span>\n<span class=\"sd\">        * save the new names to the image analysis database</span>\n<span class=\"sd\">        * wildbook will make a request to get all of the annotations, image</span>\n<span class=\"sd\">          file names, image names and animal ids</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.scripts.name_recitifer rectify_names --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(defaultdb=&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; aid_list = None</span>\n<span class=\"sd\">        &gt;&gt;&gt; common_prefix = &#39;&#39;</span>\n<span class=\"sd\">        &gt;&gt;&gt; old_img2_names = None #[&#39;img_fred.png&#39;, &#39;]</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = reasign_names1(ibs, aid_list, img_list, name_list)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">aid_list</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">aid_list</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_valid_aids</span><span class=\"p\">()</span>\n    <span class=\"c1\"># Group annotations by their current IA-name</span>\n    <span class=\"n\">nid_list</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_name_rowids</span><span class=\"p\">(</span><span class=\"n\">aid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">nid2_aids</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">group_items</span><span class=\"p\">(</span><span class=\"n\">aid_list</span><span class=\"p\">,</span> <span class=\"n\">nid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">unique_nids</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nid2_aids</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span>\n    <span class=\"n\">grouped_aids</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nid2_aids</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>\n\n    <span class=\"c1\"># Get grouped images</span>\n    <span class=\"n\">grouped_imgnames</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">unflat_map</span><span class=\"p\">(</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_image_names</span><span class=\"p\">,</span>\n                                      <span class=\"n\">grouped_aids</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Assume a mapping from old image names to old names is given.</span>\n    <span class=\"c1\"># Or just hack it in the Lewa case.</span>\n    <span class=\"k\">if</span> <span class=\"n\">old_img2_names</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">def</span> <span class=\"nf\">get_name_from_gname</span><span class=\"p\">(</span><span class=\"n\">gname</span><span class=\"p\">):</span>\n            <span class=\"kn\">from</span> <span class=\"nn\">os.path</span> <span class=\"k\">import</span> <span class=\"n\">splitext</span>\n            <span class=\"n\">gname_</span><span class=\"p\">,</span> <span class=\"n\">ext</span> <span class=\"o\">=</span> <span class=\"n\">splitext</span><span class=\"p\">(</span><span class=\"n\">gname</span><span class=\"p\">)</span>\n            <span class=\"k\">assert</span> <span class=\"n\">gname_</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"n\">common_prefix</span><span class=\"p\">),</span> <span class=\"p\">(</span>\n                <span class=\"s1\">&#39;prefix assumption is invalidated&#39;</span><span class=\"p\">)</span>\n            <span class=\"n\">gname_</span> <span class=\"o\">=</span> <span class=\"n\">gname_</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">common_prefix</span><span class=\"p\">):]</span>\n            <span class=\"k\">return</span> <span class=\"n\">gname_</span>\n        <span class=\"c1\"># Create mapping from image name to the desired &quot;name&quot; for the image.</span>\n        <span class=\"n\">old_img2_names</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">gname</span><span class=\"p\">:</span> <span class=\"n\">get_name_from_gname</span><span class=\"p\">(</span><span class=\"n\">gname</span><span class=\"p\">)</span>\n                          <span class=\"k\">for</span> <span class=\"n\">gname</span> <span class=\"ow\">in</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">grouped_imgnames</span><span class=\"p\">)}</span>\n\n    <span class=\"c1\"># Make the name of the individual associated with that annotation be the</span>\n    <span class=\"c1\"># file name prefix</span>\n    <span class=\"n\">grouped_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">old_img2_names</span><span class=\"p\">,</span> <span class=\"n\">gnames</span><span class=\"p\">)</span>\n                        <span class=\"k\">for</span> <span class=\"n\">gnames</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_imgnames</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># The task is now to map each name in unique_nids to one of these names</span>\n    <span class=\"c1\"># subject to the contraint that each name can only be used once.  This is</span>\n    <span class=\"c1\"># solved using a maximum bipartite matching. The new names are the left</span>\n    <span class=\"c1\"># nodes, the old name are the right nodes, and grouped_oldnames definse the</span>\n    <span class=\"c1\"># adjacency matrix.</span>\n    <span class=\"c1\"># NOTE: In rare cases it may be impossible to find a correct labeling using</span>\n    <span class=\"c1\"># only old names.  In this case new names will be created.</span>\n    <span class=\"n\">new_name_text</span> <span class=\"o\">=</span> <span class=\"n\">find_consistent_labeling</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">)</span>\n\n    <span class=\"n\">dry</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">dry</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Save the new names to the image analysis database</span>\n        <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">set_name_texts</span><span class=\"p\">(</span><span class=\"n\">unique_nids</span><span class=\"p\">,</span> <span class=\"n\">new_name_text</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"reasign_names2\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.reasign_names2\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">reasign_names2</span><span class=\"p\">(</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">gname_name_pairs</span><span class=\"p\">,</span> <span class=\"n\">aid_list</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n\n<span class=\"sd\">    Notes:</span>\n<span class=\"sd\">        * Given a list of pairs:  image file names (full path), animal name.</span>\n<span class=\"sd\">        * Go through all the images in the database and create a dictionary</span>\n<span class=\"sd\">        that associates the file name (full path) of the image in the database</span>\n<span class=\"sd\">        with the</span>\n<span class=\"sd\">          annotation or annotations associated with that image.</span>\n<span class=\"sd\">        * Go through the list of pairs:</span>\n<span class=\"sd\">          For each image file name, look up in the dictionary the image file</span>\n<span class=\"sd\">          name and assign the annotation associated with the image file name</span>\n<span class=\"sd\">          the animal name</span>\n<span class=\"sd\">        * Throughout this, keep a list of annotations that have been changed</span>\n<span class=\"sd\">        * Wildbook will issue a pull request to get these annotation.</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(defaultdb=&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; aid_list = None</span>\n<span class=\"sd\">        &gt;&gt;&gt; common_prefix = &#39;&#39;</span>\n<span class=\"sd\">        &gt;&gt;&gt; gname_name_pairs = [</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (&#39;easy1.JPG&#39;, &#39;easy&#39;),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (&#39;easy2.JPG&#39;, &#39;easy&#39;),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (&#39;easy3.JPG&#39;, &#39;easy&#39;),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (&#39;hard1.JPG&#39;, &#39;hard&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ]</span>\n<span class=\"sd\">        &gt;&gt;&gt; changed_pairs = reasign_names2(gname_name_pairs)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">os.path</span> <span class=\"k\">import</span> <span class=\"n\">basename</span>\n    <span class=\"k\">if</span> <span class=\"n\">aid_list</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">aid_list</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_valid_aids</span><span class=\"p\">()</span>\n    <span class=\"n\">annot_gnames</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_image_names</span><span class=\"p\">(</span><span class=\"n\">aid_list</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Other image name getters that may be useful</span>\n    <span class=\"c1\"># ibs.get_annot_image_paths(aid_list)</span>\n    <span class=\"c1\"># ibs.get_image_uris_original(ibs.get_annot_gids(aid_list))</span>\n    <span class=\"n\">gname2_aids</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">group_items</span><span class=\"p\">(</span><span class=\"n\">aid_list</span><span class=\"p\">,</span> <span class=\"n\">annot_gnames</span><span class=\"p\">)</span>\n\n    <span class=\"n\">changed_aids</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">changed_names</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">gname</span><span class=\"p\">,</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">gname_name_pairs</span><span class=\"p\">:</span>\n        <span class=\"c1\"># make sure its just the last part of the name.</span>\n        <span class=\"c1\"># Ignore preceding path</span>\n        <span class=\"n\">gname</span> <span class=\"o\">=</span> <span class=\"n\">basename</span><span class=\"p\">(</span><span class=\"n\">gname</span><span class=\"p\">)</span>\n        <span class=\"n\">aids</span> <span class=\"o\">=</span> <span class=\"n\">gname2_aids</span><span class=\"p\">[</span><span class=\"n\">gname</span><span class=\"p\">]</span>\n        <span class=\"n\">texts</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_name_texts</span><span class=\"p\">(</span><span class=\"n\">aids</span><span class=\"p\">)</span>\n        <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">text</span> <span class=\"o\">!=</span> <span class=\"n\">name</span> <span class=\"k\">for</span> <span class=\"n\">text</span> <span class=\"ow\">in</span> <span class=\"n\">texts</span><span class=\"p\">]</span>\n        <span class=\"n\">aids_</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">aids</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">aids_</span><span class=\"p\">):</span>\n            <span class=\"n\">changed_aids</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">aids_</span><span class=\"p\">)</span>\n            <span class=\"n\">changed_names</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">([</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">aids_</span><span class=\"p\">))</span>\n\n    <span class=\"n\">dry</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">dry</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Save the new names to the image analysis database</span>\n        <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">set_annot_name_texts</span><span class=\"p\">(</span><span class=\"n\">changed_aids</span><span class=\"p\">,</span> <span class=\"n\">changed_names</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Returned list tells you who was changed.</span>\n    <span class=\"n\">changed_pairs</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">changed_names</span><span class=\"p\">,</span> <span class=\"n\">changed_aids</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">changed_pairs</span></div>\n\n\n<div class=\"viewcode-block\" id=\"testdata_oldnames\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.testdata_oldnames\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">testdata_oldnames</span><span class=\"p\">(</span><span class=\"n\">n_incon_groups</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">n_con_groups</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">n_per_con</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n                      <span class=\"n\">n_per_incon</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">con_sep</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">n_empty_groups</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n    <span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n\n    <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">con_sep</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"n\">n_incon_labels</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">n_incon_groups</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">incon_labels</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_incon_labels</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Build up inconsistent groups that may share labels with other groups</span>\n    <span class=\"n\">n_per_incon_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">n_per_incon</span><span class=\"p\">),</span> <span class=\"n\">n_per_incon</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n                        <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_incon_groups</span><span class=\"p\">)]</span>\n    <span class=\"n\">incon_groups</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">incon_labels</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">replace</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">tolist</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">n_per_incon_list</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"c1\"># Build up consistent groups that may have multiple lables, but does not</span>\n    <span class=\"c1\"># share labels with any other group</span>\n    <span class=\"n\">con_groups</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">n_incon_labels</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_con_groups</span><span class=\"p\">):</span>\n        <span class=\"n\">this_n_per</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n_per_con</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">this_n_avail</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">con_sep</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">this_avail_labels</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">offset</span> <span class=\"o\">+</span> <span class=\"n\">this_n_avail</span><span class=\"p\">))</span>\n        <span class=\"n\">this_labels</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">this_avail_labels</span><span class=\"p\">,</span> <span class=\"n\">this_n_per</span><span class=\"p\">,</span> <span class=\"n\">replace</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"n\">con_groups</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">this_labels</span><span class=\"o\">.</span><span class=\"n\">tolist</span><span class=\"p\">())</span>\n        <span class=\"n\">offset</span> <span class=\"o\">+=</span> <span class=\"n\">this_n_avail</span>\n\n    <span class=\"n\">empty_groups</span> <span class=\"o\">=</span> <span class=\"p\">[[]</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_empty_groups</span><span class=\"p\">)]</span>\n\n    <span class=\"n\">grouped_oldnames</span> <span class=\"o\">=</span> <span class=\"n\">incon_groups</span> <span class=\"o\">+</span> <span class=\"n\">con_groups</span> <span class=\"o\">+</span> <span class=\"n\">empty_groups</span>\n    <span class=\"c1\"># rng.shuffle(grouped_oldnames)</span>\n    <span class=\"k\">return</span> <span class=\"n\">grouped_oldnames</span></div>\n\n\n<div class=\"viewcode-block\" id=\"simple_munkres\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.simple_munkres\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">simple_munkres</span><span class=\"p\">(</span><span class=\"n\">part_oldnames</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Defines a munkres problem to solve name rectification.</span>\n\n<span class=\"sd\">    Notes:</span>\n<span class=\"sd\">        We create a matrix where each rows represents a group of annotations in</span>\n<span class=\"sd\">        the same PCC and each column represents an original name. If there are</span>\n<span class=\"sd\">        more PCCs than original names the columns are padded with extra values.</span>\n<span class=\"sd\">        The matrix is first initialized to be negative infinity representing</span>\n<span class=\"sd\">        impossible assignments. Then for each column representing a padded</span>\n<span class=\"sd\">        name, we set we its value to $1$ indicating that each new name could be</span>\n<span class=\"sd\">        assigned to a padded name for some small profit.  Finally, let $f_{rc}$</span>\n<span class=\"sd\">        be the the number of annotations in row $r$ with an original name of</span>\n<span class=\"sd\">        $c$. Each matrix value $(r, c)$ is set to $f_{rc} + 1$ if $f_{rc} &gt; 0$,</span>\n<span class=\"sd\">        to represent how much each name ``wants&#39;&#39; to be labeled with a</span>\n<span class=\"sd\">        particular original name, and the extra one ensures that these original</span>\n<span class=\"sd\">        names are always preferred over padded names.</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.scripts.name_recitifer simple_munkres</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; part_oldnames = [[&#39;a&#39;, &#39;b&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;a&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = simple_munkres(part_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; part_oldnames = [[], [&#39;a&#39;, &#39;a&#39;], [],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                  [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;a&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = simple_munkres(part_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [None, &#39;a&#39;, None, &#39;b&#39;, None]</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; part_oldnames = [[], [&#39;b&#39;], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;e&#39;, &#39;e&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(part_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;_extra_name0&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;e&#39;]</span>\n\n<span class=\"sd\">        Profit Matrix</span>\n<span class=\"sd\">            b   a   c   e  _0</span>\n<span class=\"sd\">        0 -10 -10 -10 -10   1</span>\n<span class=\"sd\">        1   2 -10 -10 -10   1</span>\n<span class=\"sd\">        2   2   2   2 -10   1</span>\n<span class=\"sd\">        3   2 -10   2 -10   1</span>\n<span class=\"sd\">        4 -10 -10   2   3   1</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">scipy.optimize</span>\n    <span class=\"n\">unique_old_names</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">part_oldnames</span><span class=\"p\">))</span>\n    <span class=\"n\">num_new_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">part_oldnames</span><span class=\"p\">)</span>\n    <span class=\"n\">num_old_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">unique_old_names</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Create padded dummy values.  This accounts for the case where it is</span>\n    <span class=\"c1\"># impossible to uniquely map to the old db</span>\n    <span class=\"n\">num_pad</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">num_new_names</span> <span class=\"o\">-</span> <span class=\"n\">num_old_names</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"n\">num_old_names</span> <span class=\"o\">+</span> <span class=\"n\">num_pad</span>\n    <span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Allocate assignment matrix.</span>\n    <span class=\"c1\"># rows are new-names and cols are old-names.</span>\n    <span class=\"c1\"># Initially the profit of any assignment is effectively -inf</span>\n    <span class=\"c1\"># This effectively marks all assignments as invalid</span>\n    <span class=\"n\">profit_matrix</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">full</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Overwrite valid assignments with positive profits</span>\n    <span class=\"n\">oldname2_idx</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">make_index_lookup</span><span class=\"p\">(</span><span class=\"n\">unique_old_names</span><span class=\"p\">)</span>\n    <span class=\"n\">name_freq_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">names</span> <span class=\"ow\">in</span> <span class=\"n\">part_oldnames</span><span class=\"p\">]</span>\n    <span class=\"c1\"># Initialize profit of a valid assignment as 1 + freq</span>\n    <span class=\"c1\"># This incentivizes using a previously used name</span>\n    <span class=\"k\">for</span> <span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">name_freq</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">name_freq_list</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">freq</span> <span class=\"ow\">in</span> <span class=\"n\">name_freq</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">colx</span> <span class=\"o\">=</span> <span class=\"n\">oldname2_idx</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span>\n            <span class=\"n\">profit_matrix</span><span class=\"p\">[</span><span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">colx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">freq</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"c1\"># Set a much smaller profit for using an extra name</span>\n    <span class=\"c1\"># This allows the solution to always exist</span>\n    <span class=\"n\">profit_matrix</span><span class=\"p\">[:,</span> <span class=\"n\">num_old_names</span><span class=\"p\">:</span><span class=\"n\">total</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"c1\"># Convert to minimization problem</span>\n    <span class=\"n\">big_value</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">profit_matrix</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">())</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">profit_matrix</span><span class=\"o\">.</span><span class=\"n\">min</span><span class=\"p\">())</span>\n    <span class=\"n\">cost_matrix</span> <span class=\"o\">=</span> <span class=\"n\">big_value</span> <span class=\"o\">-</span> <span class=\"n\">profit_matrix</span>\n\n    <span class=\"c1\"># Use scipy implementation of munkres algorithm.</span>\n    <span class=\"n\">rx2_cx</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">optimize</span><span class=\"o\">.</span><span class=\"n\">linear_sum_assignment</span><span class=\"p\">(</span><span class=\"n\">cost_matrix</span><span class=\"p\">)))</span>\n\n    <span class=\"c1\"># Each row (new-name) has now been assigned a column (old-name)</span>\n    <span class=\"c1\"># Map this back to the input-space (using None to indicate extras)</span>\n    <span class=\"n\">cx2_name</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">unique_old_names</span><span class=\"p\">))</span>\n\n    <span class=\"k\">if</span> <span class=\"kc\">False</span><span class=\"p\">:</span>\n        <span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n        <span class=\"n\">columns</span> <span class=\"o\">=</span> <span class=\"n\">unique_old_names</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"s1\">&#39;_</span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_pad</span><span class=\"p\">)]</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Profit Matrix&#39;</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">profit_matrix</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"n\">columns</span><span class=\"p\">))</span>\n\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Cost Matrix&#39;</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">cost_matrix</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"n\">columns</span><span class=\"p\">))</span>\n\n    <span class=\"n\">assignment_</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">cx2_name</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">rx2_cx</span><span class=\"p\">[</span><span class=\"n\">rx</span><span class=\"p\">],</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n                   <span class=\"k\">for</span> <span class=\"n\">rx</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_new_names</span><span class=\"p\">)]</span>\n    <span class=\"k\">return</span> <span class=\"n\">assignment_</span></div>\n\n\n<div class=\"viewcode-block\" id=\"find_consistent_labeling\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.find_consistent_labeling\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">find_consistent_labeling</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">,</span> <span class=\"n\">extra_prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_extra_name&#39;</span><span class=\"p\">,</span>\n                             <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Solves a a maximum bipirtite matching problem to find a consistent</span>\n<span class=\"sd\">    name assignment that minimizes the number of annotations with different</span>\n<span class=\"sd\">    names. For each new grouping of annotations we assign</span>\n\n<span class=\"sd\">    For each group of annotations we must assign them all the same name, either from</span>\n\n\n\n\n<span class=\"sd\">    To reduce the running time</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        gropued_oldnames (list): A group of old names where the grouping is</span>\n<span class=\"sd\">            based on new names. For instance:</span>\n\n<span class=\"sd\">                Given:</span>\n<span class=\"sd\">                    aids      = [1, 2, 3, 4, 5]</span>\n<span class=\"sd\">                    old_names = [0, 1, 1, 1, 0]</span>\n<span class=\"sd\">                    new_names = [0, 0, 1, 1, 0]</span>\n\n<span class=\"sd\">                The grouping is</span>\n<span class=\"sd\">                    [[0, 1, 0], [1, 1]]</span>\n\n<span class=\"sd\">                This lets us keep the old names in a split case and</span>\n<span class=\"sd\">                re-use exising names and make minimal changes to</span>\n<span class=\"sd\">                current annotation names while still being consistent</span>\n<span class=\"sd\">                with the new and improved grouping.</span>\n\n<span class=\"sd\">                The output will be:</span>\n<span class=\"sd\">                    [0, 1]</span>\n\n<span class=\"sd\">                Meaning that all annots in the first group are assigned the</span>\n<span class=\"sd\">                name 0 and all annots in the second group are assigned the name</span>\n<span class=\"sd\">                1.</span>\n\n<span class=\"sd\">    References:</span>\n<span class=\"sd\">        http://stackoverflow.com/questions/1398822/assignment-problem-numpy</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.scripts.name_recitifer find_consistent_labeling</span>\n\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = testdata_oldnames(25, 15,  5, n_per_incon=5)</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames, verbose=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = testdata_oldnames(0, 15,  5, n_per_incon=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames, verbose=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = testdata_oldnames(0, 0, 0, n_per_incon=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames, verbose=1)</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; ydata = []</span>\n<span class=\"sd\">        &gt;&gt;&gt; xdata = list(range(10, 150, 50))</span>\n<span class=\"sd\">        &gt;&gt;&gt; for x in xdata:</span>\n<span class=\"sd\">        &gt;&gt;&gt;     print(&#39;x = %r&#39; % (x,))</span>\n<span class=\"sd\">        &gt;&gt;&gt;     grouped_oldnames = testdata_oldnames(x, 15,  5, n_per_incon=5)</span>\n<span class=\"sd\">        &gt;&gt;&gt;     t = ut.Timerit(3, verbose=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt;     for timer in t:</span>\n<span class=\"sd\">        &gt;&gt;&gt;         with timer:</span>\n<span class=\"sd\">        &gt;&gt;&gt;             new_names = find_consistent_labeling(grouped_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt;     ydata.append(t.ave_secs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.quit_if_noshow()</span>\n<span class=\"sd\">        &gt;&gt;&gt; import plottool as pt</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.qtensure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.multi_plot(xdata, [ydata])</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.show_if_requested()</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;b&#39;, &#39;c&#39;], [&#39;c&#39;, &#39;e&#39;, &#39;e&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames, verbose=1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;a&#39;, &#39;b&#39;, &#39;e&#39;]</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;a&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;b&#39;, &#39;a&#39;, &#39;_extra_name0&#39;]</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = [[&#39;a&#39;, &#39;b&#39;], [&#39;e&#39;], [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [], [&#39;a&#39;], [&#39;d&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;b&#39;, &#39;e&#39;, &#39;a&#39;, &#39;_extra_name0&#39;, &#39;_extra_name1&#39;, &#39;d&#39;]</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.scripts.name_recitifer import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; grouped_oldnames = [[], [&#39;a&#39;, &#39;a&#39;], [],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                     [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;a&#39;]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; new_names = find_consistent_labeling(grouped_oldnames)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(new_names)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(new_names)</span>\n<span class=\"sd\">        [&#39;_extra_name0&#39;, &#39;a&#39;, &#39;_extra_name1&#39;, &#39;b&#39;, &#39;_extra_name2&#39;]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">unique_old_names</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">))</span>\n    <span class=\"n\">n_old_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">unique_old_names</span><span class=\"p\">)</span>\n    <span class=\"n\">n_new_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Initialize assignment to all Nones</span>\n    <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kc\">None</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_new_names</span><span class=\"p\">)]</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;finding maximally consistent labeling&#39;</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;n_old_names = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_old_names</span><span class=\"p\">,))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;n_new_names = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_new_names</span><span class=\"p\">,))</span>\n\n    <span class=\"c1\"># For each old_name, determine now many new_names use it.</span>\n    <span class=\"n\">oldname_sets</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">,</span> <span class=\"n\">grouped_oldnames</span><span class=\"p\">))</span>\n    <span class=\"n\">oldname_usage</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">oldname_sets</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Any name used more than once is a conflict and must be resolved</span>\n    <span class=\"n\">conflict_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">oldname_usage</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n\n    <span class=\"c1\"># Partition into trivial and non-trivial cases</span>\n    <span class=\"n\">nontrivial_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">nontrivial_new_idxs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"n\">trivial_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">trivial_new_idxs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">new_idx</span><span class=\"p\">,</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">intersection</span><span class=\"p\">(</span><span class=\"n\">conflict_oldnames</span><span class=\"p\">):</span>\n            <span class=\"n\">nontrivial_oldnames</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n            <span class=\"n\">nontrivial_new_idxs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">new_idx</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">trivial_oldnames</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n            <span class=\"n\">trivial_new_idxs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">new_idx</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Rectify trivial cases</span>\n    <span class=\"c1\"># Any new-name that does not share any of its old-names with other</span>\n    <span class=\"c1\"># new-names can be resolved trivially</span>\n    <span class=\"n\">n_trivial_unchanged</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">n_trivial_ignored</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"n\">n_trivial_merges</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">group</span><span class=\"p\">,</span> <span class=\"n\">new_idx</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">trivial_oldnames</span><span class=\"p\">,</span> <span class=\"n\">trivial_new_idxs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"c1\"># new-names that use more than one old-name are simple merges</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"n\">n_trivial_merges</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">n_trivial_unchanged</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"n\">hitems</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span>\n            <span class=\"n\">hvals</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">hitems</span><span class=\"p\">]</span>\n            <span class=\"n\">maxval</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hvals</span><span class=\"p\">)</span>\n            <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">([</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">hitems</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">maxval</span><span class=\"p\">])</span>\n            <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">new_idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># new-names that use no old-names can be ignored</span>\n            <span class=\"n\">n_trivial_ignored</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"n\">n_trivial</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">trivial_oldnames</span><span class=\"p\">)</span>\n        <span class=\"n\">n_nontrivial</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nontrivial_oldnames</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;rectify </span><span class=\"si\">%d</span><span class=\"s1\"> trivial groups&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_trivial</span><span class=\"p\">,))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;  * n_trivial_unchanged = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_trivial_unchanged</span><span class=\"p\">,))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;  * n_trivial_merges = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_trivial_merges</span><span class=\"p\">,))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;  * n_trivial_ignored = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_trivial_ignored</span><span class=\"p\">,))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;rectify </span><span class=\"si\">%d</span><span class=\"s1\"> non-trivial groups&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">n_nontrivial</span><span class=\"p\">,))</span>\n\n    <span class=\"c1\"># Partition nontrivial_oldnames into smaller disjoint sets</span>\n    <span class=\"n\">nontrivial_oldnames_sets</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">,</span> <span class=\"n\">nontrivial_oldnames</span><span class=\"p\">))</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"nn\">nx</span>\n    <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">()</span>\n    <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">add_nodes_from</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nontrivial_oldnames_sets</span><span class=\"p\">)))</span>\n    <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">group1</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">nontrivial_oldnames_sets</span><span class=\"p\">):</span>\n        <span class=\"n\">rest</span> <span class=\"o\">=</span> <span class=\"n\">nontrivial_oldnames_sets</span><span class=\"p\">[</span><span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">:]</span>\n        <span class=\"k\">for</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">group2</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">rest</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"o\">=</span><span class=\"n\">u</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">group1</span><span class=\"o\">.</span><span class=\"n\">intersection</span><span class=\"p\">(</span><span class=\"n\">group2</span><span class=\"p\">):</span>\n                <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n    <span class=\"n\">nontrivial_partition</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connected_components</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;  * partitioned non-trivial into </span><span class=\"si\">%d</span><span class=\"s1\"> subgroups&#39;</span> <span class=\"o\">%</span>\n              <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nontrivial_partition</span><span class=\"p\">)))</span>\n        <span class=\"n\">part_size_stats</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_stats</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">,</span> <span class=\"n\">nontrivial_partition</span><span class=\"p\">))</span>\n        <span class=\"n\">stats_str</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">repr2</span><span class=\"p\">(</span><span class=\"n\">part_size_stats</span><span class=\"p\">,</span> <span class=\"n\">precision</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">strkeys</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;  * partition size stats = </span><span class=\"si\">%s</span><span class=\"s1\">&#39;</span>  <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">stats_str</span><span class=\"p\">,))</span>\n\n    <span class=\"c1\"># Rectify nontrivial cases</span>\n    <span class=\"k\">for</span> <span class=\"n\">part_idxs</span> <span class=\"ow\">in</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ProgIter</span><span class=\"p\">(</span><span class=\"n\">nontrivial_partition</span><span class=\"p\">,</span>\n                                 <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"s1\">&#39;rectify parts&#39;</span><span class=\"p\">,</span> <span class=\"n\">enabled</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">):</span>\n        <span class=\"n\">part_oldnames</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">nontrivial_oldnames</span><span class=\"p\">,</span> <span class=\"n\">part_idxs</span><span class=\"p\">)</span>\n        <span class=\"n\">part_newidxs</span>  <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">nontrivial_new_idxs</span><span class=\"p\">,</span> <span class=\"n\">part_idxs</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Rectify this part</span>\n        <span class=\"n\">assignment_</span> <span class=\"o\">=</span> <span class=\"n\">simple_munkres</span><span class=\"p\">(</span><span class=\"n\">part_oldnames</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">new_idx</span><span class=\"p\">,</span> <span class=\"n\">new_name</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">part_newidxs</span><span class=\"p\">,</span> <span class=\"n\">assignment_</span><span class=\"p\">):</span>\n            <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">new_idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">new_name</span>\n\n    <span class=\"c1\"># Any unassigned name is now given a new unique label with a prefix</span>\n    <span class=\"k\">if</span> <span class=\"n\">extra_prefix</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">num_extra</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">assignment</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;</span><span class=\"si\">%s%d</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">extra_prefix</span><span class=\"p\">,</span> <span class=\"n\">num_extra</span><span class=\"p\">,)</span>\n                <span class=\"n\">num_extra</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">assignment</span></div>\n\n\n<div class=\"viewcode-block\" id=\"find_consistent_labeling_old\"><a class=\"viewcode-back\" href=\"../../../../ibeis.scripts/#ibeis.scripts.name_recitifer.find_consistent_labeling_old\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">find_consistent_labeling_old</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">,</span> <span class=\"n\">extra_prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_extra_name&#39;</span><span class=\"p\">,</span>\n                                 <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">scipy.optimize</span>\n\n    <span class=\"n\">unique_old_names</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># TODO: find names that are only used once, and just ignore those for</span>\n    <span class=\"c1\"># optimization.</span>\n    <span class=\"c1\"># unique_set = set(unique_old_names)</span>\n    <span class=\"n\">oldname_sets</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">,</span> <span class=\"n\">grouped_oldnames</span><span class=\"p\">))</span>\n    <span class=\"n\">usage_hist</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">oldname_sets</span><span class=\"p\">))</span>\n    <span class=\"n\">conflicts</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">usage_hist</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n    <span class=\"c1\"># nonconflicts = {k for k, v in usage_hist.items() if v == 1}</span>\n\n    <span class=\"n\">conflict_groups</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">orig_idxs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">assignment</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">)</span>\n    <span class=\"n\">ntrivial</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">intersection</span><span class=\"p\">(</span><span class=\"n\">conflicts</span><span class=\"p\">):</span>\n            <span class=\"n\">orig_idxs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">)</span>\n            <span class=\"n\">conflict_groups</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">ntrivial</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n                <span class=\"n\">hitems</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span>\n                <span class=\"n\">hvals</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">hitems</span><span class=\"p\">]</span>\n                <span class=\"n\">maxval</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hvals</span><span class=\"p\">)</span>\n                <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">([</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">hitems</span> <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">maxval</span><span class=\"p\">])</span>\n                <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;rectify </span><span class=\"si\">%d</span><span class=\"s1\"> non-trivial groups&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">conflict_groups</span><span class=\"p\">),))</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;rectify </span><span class=\"si\">%d</span><span class=\"s1\"> trivial groups&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">ntrivial</span><span class=\"p\">,))</span>\n\n    <span class=\"n\">num_extra</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">conflict_groups</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">grouped_oldnames_</span> <span class=\"o\">=</span> <span class=\"n\">conflict_groups</span>\n        <span class=\"n\">unique_old_names</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames_</span><span class=\"p\">))</span>\n        <span class=\"n\">num_new_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">grouped_oldnames_</span><span class=\"p\">)</span>\n        <span class=\"n\">num_old_names</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">unique_old_names</span><span class=\"p\">)</span>\n        <span class=\"n\">extra_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n        <span class=\"c1\"># Create padded dummy values.  This accounts for the case where it is</span>\n        <span class=\"c1\"># impossible to uniquely map to the old db</span>\n        <span class=\"n\">num_extra</span> <span class=\"o\">=</span> <span class=\"n\">num_new_names</span> <span class=\"o\">-</span> <span class=\"n\">num_old_names</span>\n        <span class=\"k\">if</span> <span class=\"n\">num_extra</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">extra_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;</span><span class=\"si\">%s%d</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">extra_prefix</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">,)</span> <span class=\"k\">for</span> <span class=\"n\">count</span> <span class=\"ow\">in</span>\n                              <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_extra</span><span class=\"p\">)]</span>\n        <span class=\"k\">elif</span> <span class=\"n\">num_extra</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">extra_oldnames</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">assignable_names</span> <span class=\"o\">=</span> <span class=\"n\">unique_old_names</span> <span class=\"o\">+</span> <span class=\"n\">extra_oldnames</span>\n\n        <span class=\"n\">total</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">assignable_names</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Allocate assignment matrix</span>\n        <span class=\"c1\"># Start with a large negative value indicating</span>\n        <span class=\"c1\"># that you must select from your assignments only</span>\n        <span class=\"n\">profit_matrix</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"n\">total</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">total</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Populate assignment profit matrix</span>\n        <span class=\"n\">oldname2_idx</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">make_index_lookup</span><span class=\"p\">(</span><span class=\"n\">assignable_names</span><span class=\"p\">)</span>\n        <span class=\"n\">name_freq_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">dict_hist</span><span class=\"p\">(</span><span class=\"n\">names</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">names</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_oldnames_</span><span class=\"p\">]</span>\n        <span class=\"c1\"># Initialize base profit for using a previously used name</span>\n        <span class=\"k\">for</span> <span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">name_freq</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">name_freq_list</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">freq</span> <span class=\"ow\">in</span> <span class=\"n\">name_freq</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"n\">colx</span> <span class=\"o\">=</span> <span class=\"n\">oldname2_idx</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span>\n                <span class=\"n\">profit_matrix</span><span class=\"p\">[</span><span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">colx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"c1\"># Now add in the real profit</span>\n        <span class=\"k\">for</span> <span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">name_freq</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">name_freq_list</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">freq</span> <span class=\"ow\">in</span> <span class=\"n\">name_freq</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"n\">colx</span> <span class=\"o\">=</span> <span class=\"n\">oldname2_idx</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span>\n                <span class=\"n\">profit_matrix</span><span class=\"p\">[</span><span class=\"n\">rowx</span><span class=\"p\">,</span> <span class=\"n\">colx</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">freq</span>\n        <span class=\"c1\"># Set a small profit for using an extra name</span>\n        <span class=\"n\">extra_colxs</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">oldname2_idx</span><span class=\"p\">,</span> <span class=\"n\">extra_oldnames</span><span class=\"p\">)</span>\n        <span class=\"n\">profit_matrix</span><span class=\"p\">[:,</span> <span class=\"n\">extra_colxs</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n        <span class=\"c1\"># Convert to minimization problem</span>\n        <span class=\"n\">big_value</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">profit_matrix</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">())</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">profit_matrix</span><span class=\"o\">.</span><span class=\"n\">min</span><span class=\"p\">())</span>\n        <span class=\"n\">cost_matrix</span> <span class=\"o\">=</span> <span class=\"n\">big_value</span> <span class=\"o\">-</span> <span class=\"n\">profit_matrix</span>\n\n        <span class=\"c1\"># Don&#39;t use munkres, it is pure python and very slow. Use scipy instead</span>\n        <span class=\"n\">indexes</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">optimize</span><span class=\"o\">.</span><span class=\"n\">linear_sum_assignment</span><span class=\"p\">(</span><span class=\"n\">cost_matrix</span><span class=\"p\">)))</span>\n\n        <span class=\"c1\"># Map output to be aligned with input</span>\n        <span class=\"n\">rx2_cx</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">indexes</span><span class=\"p\">)</span>\n        <span class=\"n\">assignment_</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">assignable_names</span><span class=\"p\">[</span><span class=\"n\">rx2_cx</span><span class=\"p\">[</span><span class=\"n\">rx</span><span class=\"p\">]]</span>\n                       <span class=\"k\">for</span> <span class=\"n\">rx</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_new_names</span><span class=\"p\">)]</span>\n\n        <span class=\"c1\"># Reintegrate trivial values</span>\n        <span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">orig_idxs</span><span class=\"p\">,</span> <span class=\"n\">assignment_</span><span class=\"p\">):</span>\n            <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">assignment</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">assignment</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;</span><span class=\"si\">%s%d</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">extra_prefix</span><span class=\"p\">,</span> <span class=\"n\">num_extra</span><span class=\"p\">,)</span>\n            <span class=\"n\">num_extra</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">assignment</span></div>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.scripts.name_recitifer</span>\n<span class=\"sd\">        python -m ibeis.scripts.name_recitifer --allexamples</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">multiprocessing</span>\n    <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">freeze_support</span><span class=\"p\">()</span>  <span class=\"c1\"># for win32</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>  <span class=\"c1\"># NOQA</span>\n    <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">doctest_funcs</span><span class=\"p\">()</span>\n</pre></div>", "current_page_name": "_modules/ibeis/scripts/name_recitifer", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}