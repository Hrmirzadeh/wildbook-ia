{"parents": [{"link": "../../../../", "title": "Module code"}, {"link": "../../../", "title": "ibeis"}, {"link": "../../", "title": "ibeis.algo"}, {"link": "../", "title": "ibeis.algo.smk"}], "title": "ibeis.algo.smk.smk_funcs", "body": "<h1>Source code for ibeis.algo.smk.smk_funcs</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"c1\"># -*- coding: utf-8 -*-</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">References:</span>\n<span class=\"sd\">    Jegou&#39;s Source Code, Data, and Publications</span>\n<span class=\"sd\">    http://people.rennes.inria.fr/Herve.Jegou/publications.html</span>\n\n<span class=\"sd\">    To aggregate or not to aggregate: selective match kernels for image search</span>\n<span class=\"sd\">    https://hal.inria.fr/hal-00864684/document</span>\n\n<span class=\"sd\">    Image search with selective match kernels: aggregation across single and multiple images</span>\n<span class=\"sd\">    http://image.ntua.gr/iva/files/Tolias_ijcv15_iasmk.pdf</span>\n\n<span class=\"sd\">    Negative evidences and co-occurrences in image retrieval: the benefit of PCA and whitening</span>\n<span class=\"sd\">    https://hal.inria.fr/file/index/docid/722626/filename/jegou_chum_eccv2012.pdf</span>\n\n<span class=\"sd\">    Revisiting the VLAD image representation</span>\n<span class=\"sd\">    https://hal.inria.fr/file/index/docid/850249/filename/nextvlad_hal.pdf</span>\n\n<span class=\"sd\">    Aggregating local descriptors into a compact image representation</span>\n<span class=\"sd\">    https://lear.inrialpes.fr/pubs/2010/JDSP10/jegou_compactimagerepresentation.pdf</span>\n\n<span class=\"sd\">    Large-scale image retrieval with compressed Fisher vectors</span>\n<span class=\"sd\">    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.401.9140&amp;rep=rep1&amp;type=pdf</span>\n\n<span class=\"sd\">    Improving Bag of Features</span>\n<span class=\"sd\">    http://lear.inrialpes.fr/pubs/2010/JDS10a/jegou_improvingbof_preprint.pdf</span>\n\n<span class=\"sd\">    Lost in Quantization</span>\n<span class=\"sd\">    http://www.robots.ox.ac.uk/~vgg/publications/papers/philbin08.ps.gz</span>\n\n<span class=\"sd\">    A Context Dissimilarity Measure for Accurate and Efficient Image Search</span>\n<span class=\"sd\">    https://lear.inrialpes.fr/pubs/2007/JHS07/jegou_cdm.pdf</span>\n\n<span class=\"sd\">    Video Google: A text retrieval approach to object matching in videos</span>\n<span class=\"sd\">    http://www.robots.ox.ac.uk/~vgg/publications/papers/sivic03.pdf</span>\n\n<span class=\"sd\">    Hamming embedding and weak geometric consistency for large scale image search</span>\n<span class=\"sd\">    https://lear.inrialpes.fr/pubs/2008/JDS08/jegou_hewgc08.pdf</span>\n\n<span class=\"sd\">    Three things everyone should know to improve object retrieval</span>\n<span class=\"sd\">    https://www.robots.ox.ac.uk/~vgg/publications/2012/Arandjelovic12/arandjelovic12.pdf</span>\n\n<span class=\"sd\">    Object retrieval with large vocabularies and fast spatial matching</span>\n<span class=\"sd\">    http://www.robots.ox.ac.uk:5000/~vgg/publications/2007/Philbin07/philbin07.pdf</span>\n\n<span class=\"sd\">    Aggregating Local Descriptors into Compact Codes</span>\n<span class=\"sd\">    https://hal.inria.fr/file/index/docid/633013/filename/jegou_aggregate.pdf</span>\n\n<span class=\"sd\">    Local visual query expansion</span>\n<span class=\"sd\">    https://hal.inria.fr/hal-00840721/PDF/RR-8325.pdf</span>\n\n<span class=\"sd\">    Root SIFT technique</span>\n<span class=\"sd\">    https://hal.inria.fr/hal-00688169/document</span>\n\n<span class=\"sd\">    Fisher Kernel For Large Scale Classification</span>\n<span class=\"sd\">    https://www.robots.ox.ac.uk/~vgg/rg/papers/peronnin_etal_ECCV10.pdf</span>\n\n<span class=\"sd\">    Orientation covariant aggregation of local descriptors with embeddings</span>\n<span class=\"sd\">    https://arxiv.org/pdf/1407.2170.pdf</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"k\">import</span> <span class=\"n\">absolute_import</span><span class=\"p\">,</span> <span class=\"n\">division</span><span class=\"p\">,</span> <span class=\"n\">print_function</span><span class=\"p\">,</span> <span class=\"n\">unicode_literals</span>\n<span class=\"kn\">from</span> <span class=\"nn\">six.moves</span> <span class=\"k\">import</span> <span class=\"nb\">zip</span>\n<span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>\n<span class=\"kn\">import</span> <span class=\"nn\">vtool</span> <span class=\"k\">as</span> <span class=\"nn\">vt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"p\">(</span><span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"n\">rrr</span><span class=\"p\">,</span> <span class=\"n\">profile</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">inject2</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n\n<div class=\"viewcode-block\" id=\"cast_residual_integer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.cast_residual_integer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">cast_residual_integer</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    quantize residual vectors to 8-bits using the same trunctation hack as in</span>\n<span class=\"sd\">    SIFT. values will typically not reach the maximum, so we can multiply by a</span>\n<span class=\"sd\">    higher number for better fidelity.</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        rvecs (ndarray[float64_t]):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        ndarray[uint8_t]:</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs cast_residual_integer --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; rvecs = testdata_rvecs(dim=128)[&#39;rvecs&#39;][4:]</span>\n<span class=\"sd\">        &gt;&gt;&gt; rvecs_int8 = cast_residual_integer(rvecs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; rvecs_float = uncast_residual_integer(rvecs_int8)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Casting from float to int8 will result in a max quantization error</span>\n<span class=\"sd\">        &gt;&gt;&gt; measured_error = np.abs(rvecs_float - rvecs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # But there are limits on what this error can be</span>\n<span class=\"sd\">        &gt;&gt;&gt; cutoff = 127  # np.iinfo(np.int8).max</span>\n<span class=\"sd\">        &gt;&gt;&gt; fidelity = 255.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; theory_error_in = 1 / fidelity</span>\n<span class=\"sd\">        &gt;&gt;&gt; theory_error_out = (fidelity - cutoff) / fidelity</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Determine if any component values exceed the cutoff</span>\n<span class=\"sd\">        &gt;&gt;&gt; is_inside = (np.abs(rvecs * fidelity) &lt; cutoff)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Check theoretical maximum for values inside and outside cutoff</span>\n<span class=\"sd\">        &gt;&gt;&gt; error_stats_in = ut.get_stats(measured_error[is_inside])</span>\n<span class=\"sd\">        &gt;&gt;&gt; error_stats_out = ut.get_stats(measured_error[~is_inside])</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;inside cutoff error stats: &#39; + ut.repr4(error_stats_in, precision=8))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;outside cutoff error stats: &#39; + ut.repr4(error_stats_out, precision=8))</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert rvecs_int8.dtype == np.int8</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert np.all(measured_error[is_inside] &lt; theory_error_in)</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert np.all(measured_error[~is_inside] &lt; theory_error_out)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># maybe don&#39;t round?</span>\n    <span class=\"c1\">#return np.clip(rvecs * 255.0, -127, 127).astype(np.int8)</span>\n    <span class=\"c1\"># TODO: -128, 127</span>\n    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">clip</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">round</span><span class=\"p\">(</span><span class=\"n\">rvecs</span> <span class=\"o\">*</span> <span class=\"mf\">255.0</span><span class=\"p\">),</span> <span class=\"o\">-</span><span class=\"mi\">127</span><span class=\"p\">,</span> <span class=\"mi\">127</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int8</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"uncast_residual_integer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.uncast_residual_integer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">uncast_residual_integer</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        rvecs (ndarray[uint8_t]):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        ndarray[float64_t]:</span>\n\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">return</span> <span class=\"n\">rvecs</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">255.0</span></div>\n\n\n<div class=\"viewcode-block\" id=\"compute_stacked_agg_rvecs\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.compute_stacked_agg_rvecs\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">compute_stacked_agg_rvecs</span><span class=\"p\">(</span><span class=\"n\">words</span><span class=\"p\">,</span> <span class=\"n\">flat_wxs_assign</span><span class=\"p\">,</span> <span class=\"n\">flat_vecs</span><span class=\"p\">,</span> <span class=\"n\">flat_offsets</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    More efficient version of agg on a stacked structure</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        words (ndarray): entire vocabulary of words</span>\n<span class=\"sd\">        flat_wxs_assign (ndarray): maps a stacked index to word index</span>\n<span class=\"sd\">        flat_vecs (ndarray): stacked SIFT descriptors</span>\n<span class=\"sd\">        flat_offsets (ndarray): offset positions per annotation</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; data = testdata_rvecs(dim=2, nvecs=1000, nannots=10)</span>\n<span class=\"sd\">        &gt;&gt;&gt; words = data[&#39;words&#39;]</span>\n<span class=\"sd\">        &gt;&gt;&gt; flat_offsets = data[&#39;offset_list&#39;]</span>\n<span class=\"sd\">        &gt;&gt;&gt; flat_wxs_assign, flat_vecs = ut.take(data, [&#39;idx_to_wx&#39;, &#39;vecs&#39;])</span>\n<span class=\"sd\">        &gt;&gt;&gt; tup = compute_stacked_agg_rvecs(words, flat_wxs_assign, flat_vecs, flat_offsets)</span>\n<span class=\"sd\">        &gt;&gt;&gt; all_agg_vecs, all_error_flags, agg_offset_list = tup</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_rvecs_list = [all_agg_vecs[l:r] for l, r in ut.itertwo(agg_offset_list)]</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_flags_list = [all_error_flags[l:r] for l, r in ut.itertwo(agg_offset_list)]</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert len(agg_flags_list) == len(flat_offsets) - 1</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; data = testdata_rvecs(dim=2, nvecs=100, nannots=5)</span>\n<span class=\"sd\">        &gt;&gt;&gt; words = data[&#39;words&#39;]</span>\n<span class=\"sd\">        &gt;&gt;&gt; flat_offsets = data[&#39;offset_list&#39;]</span>\n<span class=\"sd\">        &gt;&gt;&gt; flat_wxs_assign, flat_vecs = ut.take(data, [&#39;idx_to_wx&#39;, &#39;vecs&#39;])</span>\n<span class=\"sd\">        &gt;&gt;&gt; tup = compute_stacked_agg_rvecs(words, flat_wxs_assign, flat_vecs, flat_offsets)</span>\n<span class=\"sd\">        &gt;&gt;&gt; all_agg_vecs, all_error_flags, agg_offset_list = tup</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_rvecs_list = [all_agg_vecs[l:r] for l, r in ut.itertwo(agg_offset_list)]</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_flags_list = [all_error_flags[l:r] for l, r in ut.itertwo(agg_offset_list)]</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert len(agg_flags_list) == len(flat_offsets) - 1</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">grouped_wxs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">flat_wxs_assign</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">:</span><span class=\"n\">r</span><span class=\"p\">]</span>\n                   <span class=\"k\">for</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">itertwo</span><span class=\"p\">(</span><span class=\"n\">flat_offsets</span><span class=\"p\">)]</span>\n\n    <span class=\"c1\"># Assume single assignment, aggregate everything</span>\n    <span class=\"c1\"># across the entire database</span>\n    <span class=\"n\">flat_offsets</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">flat_offsets</span><span class=\"p\">)</span>\n\n    <span class=\"n\">idx_to_dx</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n        <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">searchsorted</span><span class=\"p\">(</span>\n            <span class=\"n\">flat_offsets</span><span class=\"p\">,</span>\n            <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">flat_wxs_assign</span><span class=\"p\">)),</span>\n            <span class=\"n\">side</span><span class=\"o\">=</span><span class=\"s1\">&#39;right&#39;</span>\n        <span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n    <span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">flat_wxs_assign</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">):</span>\n        <span class=\"n\">wx_list</span> <span class=\"o\">=</span> <span class=\"n\">flat_wxs_assign</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compressed</span><span class=\"p\">()</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">wx_list</span> <span class=\"o\">=</span> <span class=\"n\">flat_wxs_assign</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()</span>\n    <span class=\"n\">unique_wx</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">group_indices</span><span class=\"p\">(</span><span class=\"n\">wx_list</span><span class=\"p\">)</span>\n\n    <span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"n\">flat_vecs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">flat_wxs_assign</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">):</span>\n        <span class=\"n\">dx_to_wxs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">wxs</span><span class=\"o\">.</span><span class=\"n\">compressed</span><span class=\"p\">())</span>\n                     <span class=\"k\">for</span> <span class=\"n\">wxs</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_wxs</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">dx_to_wxs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">wxs</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">())</span>\n                     <span class=\"k\">for</span> <span class=\"n\">wxs</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_wxs</span><span class=\"p\">]</span>\n    <span class=\"n\">dx_to_nagg</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">wxs</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">wxs</span> <span class=\"ow\">in</span> <span class=\"n\">dx_to_wxs</span><span class=\"p\">]</span>\n    <span class=\"n\">num_agg_vecs</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">dx_to_nagg</span><span class=\"p\">)</span>\n    <span class=\"c1\"># all_agg_wxs = np.hstack(dx_to_wxs)</span>\n    <span class=\"n\">agg_offset_list</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">dx_to_nagg</span><span class=\"p\">))</span>\n    <span class=\"c1\"># Preallocate agg residuals for all dxs</span>\n    <span class=\"n\">all_agg_vecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">((</span><span class=\"n\">num_agg_vecs</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">),</span>\n                            <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n    <span class=\"n\">all_agg_vecs</span><span class=\"p\">[:,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span>\n\n    <span class=\"c1\"># precompute agg residual stack</span>\n    <span class=\"n\">i_to_dxs</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_grouping</span><span class=\"p\">(</span><span class=\"n\">idx_to_dx</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span><span class=\"p\">)</span>\n    <span class=\"n\">subgroup</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">group_indices</span><span class=\"p\">(</span><span class=\"n\">dxs</span><span class=\"p\">)</span>\n                <span class=\"k\">for</span> <span class=\"n\">dxs</span> <span class=\"ow\">in</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ProgIter</span><span class=\"p\">(</span><span class=\"n\">i_to_dxs</span><span class=\"p\">)]</span>\n    <span class=\"n\">i_to_unique_dxs</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take_column</span><span class=\"p\">(</span><span class=\"n\">subgroup</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">i_to_dx_groupxs</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">take_column</span><span class=\"p\">(</span><span class=\"n\">subgroup</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">num_words</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">unique_wx</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Overall this takes 5 minutes and 21 seconds</span>\n    <span class=\"c1\"># I think the other method takes about 12 minutes</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ProgIter</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_words</span><span class=\"p\">),</span> <span class=\"s1\">&#39;agg&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">wx</span> <span class=\"o\">=</span> <span class=\"n\">unique_wx</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"n\">xs</span> <span class=\"o\">=</span> <span class=\"n\">groupxs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"n\">dxs</span> <span class=\"o\">=</span> <span class=\"n\">i_to_unique_dxs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"n\">dx_groupxs</span> <span class=\"o\">=</span> <span class=\"n\">i_to_dx_groupxs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"n\">word</span> <span class=\"o\">=</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">wx</span><span class=\"p\">:</span><span class=\"n\">wx</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n\n        <span class=\"n\">offsets1</span> <span class=\"o\">=</span> <span class=\"n\">agg_offset_list</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">dxs</span><span class=\"p\">)</span>\n        <span class=\"n\">offsets2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">dx_to_wxs</span><span class=\"p\">[</span><span class=\"n\">dx</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">wx</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n                    <span class=\"k\">for</span> <span class=\"n\">dx</span> <span class=\"ow\">in</span> <span class=\"n\">dxs</span><span class=\"p\">]</span>\n        <span class=\"n\">offsets</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">offsets1</span><span class=\"p\">,</span> <span class=\"n\">offsets2</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">offsets1</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># if __debug__:</span>\n        <span class=\"c1\">#     assert np.bincount(dxs).max() &lt; 2</span>\n        <span class=\"c1\">#     offset = agg_offset_list[dxs[0]]</span>\n        <span class=\"c1\">#     assert np.all(dx_to_wxs[dxs[0]] == all_agg_wxs[offset:offset +</span>\n        <span class=\"c1\">#                                                    dx_to_nagg[dxs[0]]])</span>\n\n        <span class=\"c1\"># Compute residuals</span>\n        <span class=\"n\">rvecs</span> <span class=\"o\">=</span> <span class=\"n\">flat_vecs</span><span class=\"p\">[</span><span class=\"n\">xs</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">word</span>\n        <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">rvecs</span><span class=\"p\">)</span>\n        <span class=\"n\">rvecs</span><span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"c1\"># Aggregate across same images</span>\n        <span class=\"n\">grouped_rvecs</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_grouping</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">dx_groupxs</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">agg_rvecs_</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">rvec_group</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n                      <span class=\"k\">for</span> <span class=\"n\">rvec_group</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_rvecs</span><span class=\"p\">]</span>\n        <span class=\"c1\"># agg_rvecs = np.vstack(agg_rvecs_)</span>\n        <span class=\"n\">all_agg_vecs</span><span class=\"p\">[</span><span class=\"n\">offsets</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">agg_rvecs_</span>\n\n    <span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">any</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">all_agg_vecs</span><span class=\"p\">))</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Apply normalization&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">all_agg_vecs</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">all_agg_vecs</span><span class=\"p\">)</span>\n    <span class=\"n\">all_error_flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">all_agg_vecs</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">all_agg_vecs</span><span class=\"p\">[</span><span class=\"n\">all_error_flags</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n    <span class=\"c1\"># ndocs_per_word1 = np.array(ut.lmap(len, wx_to_unique_dxs))</span>\n    <span class=\"c1\"># ndocs_total1 = len(flat_offsets) - 1</span>\n    <span class=\"c1\"># idf1 = smk_funcs.inv_doc_freq(ndocs_total1, ndocs_per_word1)</span>\n\n    <span class=\"n\">tup</span> <span class=\"o\">=</span> <span class=\"n\">all_agg_vecs</span><span class=\"p\">,</span> <span class=\"n\">all_error_flags</span><span class=\"p\">,</span> <span class=\"n\">agg_offset_list</span>\n    <span class=\"k\">return</span> <span class=\"n\">tup</span></div>\n\n\n<div class=\"viewcode-block\" id=\"compute_rvec\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.compute_rvec\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">compute_rvec</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">word</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Compute residual vectors phi(x_c)</span>\n\n<span class=\"sd\">    Subtract each vector from its quantized word to get the resiudal, then</span>\n<span class=\"sd\">    normalize residuals to unit length.</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs compute_rvec --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; vecs, words = ut.take(testdata_rvecs(), [&#39;vecs&#39;, &#39;words&#39;])</span>\n<span class=\"sd\">        &gt;&gt;&gt; word = words[-1]</span>\n<span class=\"sd\">        &gt;&gt;&gt; rvecs, error_flags = compute_rvec(vecs, word)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.quit_if_noshow()</span>\n<span class=\"sd\">        &gt;&gt;&gt; import plottool as pt</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.figure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; # recenter residuals for visualization</span>\n<span class=\"sd\">        &gt;&gt;&gt; cvecs = (rvecs + word[None, :])</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(word[0], word[1], &#39;r*&#39;, markersize=12, label=&#39;word&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(vecs.T[0], vecs.T[1], &#39;go&#39;, label=&#39;original vecs&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(cvecs.T[0], cvecs.T[1], &#39;b.&#39;, label=&#39;re-centered rvec&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.draw_line_segments2(cvecs, [word] * len(cvecs), alpha=.5, color=&#39;black&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.gca().set_aspect(&#39;equal&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.legend()</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.show_if_requested()</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">rvecs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">subtract</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">),</span> <span class=\"n\">word</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">))</span>\n    <span class=\"c1\"># If a vec is a word then the residual is 0 and it cant be L2 noramlized.</span>\n    <span class=\"n\">error_flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">(</span><span class=\"n\">rvecs</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">rvecs</span><span class=\"p\">)</span>\n    <span class=\"c1\"># reset these values to zero</span>\n    <span class=\"k\">if</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">any</span><span class=\"p\">(</span><span class=\"n\">error_flags</span><span class=\"p\">):</span>\n        <span class=\"n\">rvecs</span><span class=\"p\">[</span><span class=\"n\">error_flags</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">return</span> <span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">error_flags</span></div>\n\n\n<div class=\"viewcode-block\" id=\"aggregate_rvecs\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.aggregate_rvecs\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">aggregate_rvecs</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">maws</span><span class=\"p\">,</span> <span class=\"n\">error_flags</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Compute aggregated residual vectors Phi(X_c)</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs aggregate_rvecs --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; vecs, words = ut.take(testdata_rvecs(), [&#39;vecs&#39;, &#39;words&#39;])</span>\n<span class=\"sd\">        &gt;&gt;&gt; word = words[-1]</span>\n<span class=\"sd\">        &gt;&gt;&gt; rvecs, error_flags = compute_rvec(vecs, word)</span>\n<span class=\"sd\">        &gt;&gt;&gt; maws = [1.0] * len(rvecs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_rvec, agg_flag = aggregate_rvecs(rvecs, maws, error_flags)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.quit_if_noshow()</span>\n<span class=\"sd\">        &gt;&gt;&gt; import plottool as pt</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.qt4ensure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.figure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; # recenter residuals for visualization</span>\n<span class=\"sd\">        &gt;&gt;&gt; agg_cvec = agg_rvec + word</span>\n<span class=\"sd\">        &gt;&gt;&gt; cvecs = (rvecs + word[None, :])</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(word[0], word[1], &#39;r*&#39;, markersize=12, label=&#39;word&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(agg_cvec[0], agg_cvec[1], &#39;ro&#39;, label=&#39;re-centered agg_rvec&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(vecs.T[0], vecs.T[1], &#39;go&#39;, label=&#39;original vecs&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(cvecs.T[0], cvecs.T[1], &#39;b.&#39;, label=&#39;re-centered rvec&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.draw_line_segments2([word] * len(cvecs), cvecs, alpha=.5, color=&#39;black&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.draw_line_segments2([word], [agg_cvec], alpha=.5, color=&#39;red&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.gca().set_aspect(&#39;equal&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.legend()</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.show_if_requested()</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Propogate errors from previous step</span>\n    <span class=\"n\">agg_flag</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">any</span><span class=\"p\">(</span><span class=\"n\">error_flags</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">rvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;cannot compute without rvecs&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">rvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Efficiency shortcut</span>\n        <span class=\"n\">agg_rvec</span> <span class=\"o\">=</span> <span class=\"n\">rvecs</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Prealloc residual vector, take the weighted sum and renormalize.</span>\n        <span class=\"n\">agg_rvec</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"n\">rvecs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n        <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">agg_rvec</span>\n\n        <span class=\"k\">if</span> <span class=\"kc\">False</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Take weighted average of multi-assigned vectors</span>\n            <span class=\"n\">coeff</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">divide</span><span class=\"p\">(</span><span class=\"n\">maws</span><span class=\"p\">,</span> <span class=\"n\">maws</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">())[:,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>\n            <span class=\"n\">agg_rvec</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">coeff</span> <span class=\"o\">*</span> <span class=\"n\">rvecs</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Don&#39;t consider multiple assignment weights</span>\n            <span class=\"n\">agg_rvec</span> <span class=\"o\">=</span> <span class=\"n\">rvecs</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n        <span class=\"n\">is_zero</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">(</span><span class=\"n\">agg_rvec</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n        <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">agg_rvec</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">agg_rvec</span><span class=\"p\">)</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">is_zero</span><span class=\"p\">:</span>\n            <span class=\"n\">agg_flag</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"k\">return</span> <span class=\"n\">agg_rvec</span><span class=\"p\">,</span> <span class=\"n\">agg_flag</span></div>\n\n\n<div class=\"viewcode-block\" id=\"weight_multi_assigns\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.weight_multi_assigns\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">weight_multi_assigns</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">_idx_to_wdist</span><span class=\"p\">,</span> <span class=\"n\">massign_alpha</span><span class=\"o\">=</span><span class=\"mf\">1.2</span><span class=\"p\">,</span>\n                         <span class=\"n\">massign_sigma</span><span class=\"o\">=</span><span class=\"mf\">80.0</span><span class=\"p\">,</span> <span class=\"n\">massign_equal_weights</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Multi Assignment Weight Filtering from Improving Bag of Features</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        massign_equal_weights (): Turns off soft weighting. Gives all assigned</span>\n<span class=\"sd\">            vectors weight 1</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        tuple : (idx_to_wxs, idx_to_maws)</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wx = np.array([[0, 1], [2, 3], [4, 5], [2, 0]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wdist = np.array([[.1, .11], [.2, .25], [.03, .25], [0, 1]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_alpha = 1.2</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_sigma = 80.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_equal_weights = False</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs, idx_to_maws = weight_multi_assigns(</span>\n<span class=\"sd\">        &gt;&gt;&gt;     _idx_to_wx, _idx_to_wdist, massign_alpha, massign_sigma,</span>\n<span class=\"sd\">        &gt;&gt;&gt;     massign_equal_weights)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;idx_to_wxs = %s&#39; % (ut.repr2(idx_to_wxs.astype(np.float64)),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result += &#39;\\nidx_to_maws = %s&#39; % (ut.repr2(idx_to_maws, precision=2),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        idx_to_wxs = np.ma.MaskedArray([[0., 1.],</span>\n<span class=\"sd\">                           [2., inf],</span>\n<span class=\"sd\">                           [4., inf],</span>\n<span class=\"sd\">                           [2., 0.]])</span>\n<span class=\"sd\">        idx_to_maws = np.ma.MaskedArray([[0.5, 0.5],</span>\n<span class=\"sd\">                           [1. , inf],</span>\n<span class=\"sd\">                           [1. , inf],</span>\n<span class=\"sd\">                           [0.5, 0.5]])</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wx = np.array([[0, 1], [2, 3], [4, 5], [2, 0]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wdist = np.array([[.1, .11], [.2, .25], [.03, .25], [0, 1]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wx = _idx_to_wx.astype(np.int32)</span>\n<span class=\"sd\">        &gt;&gt;&gt; _idx_to_wdist = _idx_to_wdist.astype(np.float32)</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_alpha = 1.2</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_sigma = 80.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_equal_weights = True</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs, idx_to_maws = weight_multi_assigns(</span>\n<span class=\"sd\">        &gt;&gt;&gt;     _idx_to_wx, _idx_to_wdist, massign_alpha, massign_sigma,</span>\n<span class=\"sd\">        &gt;&gt;&gt;     massign_equal_weights)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;idx_to_wxs = %s&#39; % (ut.repr2(idx_to_wxs.astype(np.float64)),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result += &#39;\\nidx_to_maws = %s&#39; % (ut.repr2(idx_to_maws, precision=2),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        idx_to_wxs = np.ma.MaskedArray([[0., 1.],</span>\n<span class=\"sd\">                           [2., inf],</span>\n<span class=\"sd\">                           [4., inf],</span>\n<span class=\"sd\">                           [2., 0.]])</span>\n<span class=\"sd\">        idx_to_maws = np.ma.MaskedArray([[1., 1.],</span>\n<span class=\"sd\">                           [1., inf],</span>\n<span class=\"sd\">                           [1., inf],</span>\n<span class=\"sd\">                           [1., 1.]])</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">_idx_to_wx</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">idx_to_wxs</span> <span class=\"o\">=</span> <span class=\"n\">_idx_to_wx</span><span class=\"o\">.</span><span class=\"n\">tolist</span><span class=\"p\">()</span>\n        <span class=\"n\">idx_to_maws</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mf\">1.0</span><span class=\"p\">]]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Valid word assignments are beyond fraction of distance to the nearest word</span>\n        <span class=\"n\">ma_thresh</span> <span class=\"o\">=</span> <span class=\"n\">_idx_to_wdist</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"c1\"># If the nearest word has distance 0 then this threshold is too hard so</span>\n        <span class=\"c1\"># we should use the distance to the second nearest word.</span>\n        <span class=\"n\">flag_too_close</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isclose</span><span class=\"p\">(</span><span class=\"n\">ma_thresh</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">ma_thresh</span><span class=\"p\">[</span><span class=\"n\">flag_too_close</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_idx_to_wdist</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"n\">flag_too_close</span><span class=\"p\">]</span>\n        <span class=\"c1\"># Compute a threshold based on the nearest assignment.</span>\n        <span class=\"n\">eps</span> <span class=\"o\">=</span> <span class=\"o\">.</span><span class=\"mi\">001</span>\n        <span class=\"n\">ma_thresh</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">eps</span><span class=\"p\">,</span> <span class=\"n\">ma_thresh</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">ma_thresh</span><span class=\"p\">)</span>\n        <span class=\"n\">ma_thresh</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">(</span><span class=\"n\">massign_alpha</span><span class=\"p\">,</span> <span class=\"n\">ma_thresh</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">ma_thresh</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Invalidate assignments that are too far away</span>\n        <span class=\"n\">invalid</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">greater_equal</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wdist</span><span class=\"p\">,</span> <span class=\"n\">ma_thresh</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span><span class=\"p\">:</span>\n            <span class=\"n\">nInvalid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">invalid</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">invalid</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(),</span> <span class=\"n\">invalid</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[maw] + massign_alpha = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">massign_alpha</span><span class=\"p\">,))</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[maw] + massign_sigma = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">massign_sigma</span><span class=\"p\">,))</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[maw] + massign_equal_weights = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">massign_equal_weights</span><span class=\"p\">,))</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[maw] * Marked </span><span class=\"si\">%d</span><span class=\"s1\">/</span><span class=\"si\">%d</span><span class=\"s1\"> assignments as invalid&#39;</span> <span class=\"o\">%</span> <span class=\"n\">nInvalid</span><span class=\"p\">)</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">massign_equal_weights</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Performance hack from jegou paper: just give everyone equal weight</span>\n            <span class=\"n\">idx_to_wxs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">invalid</span><span class=\"p\">,</span>\n                                            <span class=\"n\">fill_value</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"c1\"># idx_to_wxs  = ut.lmap(ut.filter_Nones, masked_wxs.tolist())</span>\n            <span class=\"n\">idx_to_maws</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">fill_value</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">,</span>\n                                     <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n            <span class=\"n\">idx_to_maws</span><span class=\"o\">.</span><span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">mask</span>\n            <span class=\"c1\"># idx_to_maws = [np.ones(len(wxs), dtype=np.float32)</span>\n            <span class=\"c1\">#                for wxs in idx_to_wxs]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># More natural weighting scheme</span>\n            <span class=\"c1\"># Weighting as in Lost in Quantization</span>\n            <span class=\"n\">gauss_numer</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">negative</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wdist</span><span class=\"p\">)</span>\n            <span class=\"n\">gauss_denom</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">massign_sigma</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n            <span class=\"n\">gauss_exp</span>   <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">divide</span><span class=\"p\">(</span><span class=\"n\">gauss_numer</span><span class=\"p\">,</span> <span class=\"n\">gauss_denom</span><span class=\"p\">)</span>\n            <span class=\"n\">unnorm_maw</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">gauss_exp</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Mask invalid multiassignment weights</span>\n            <span class=\"n\">masked_unorm_maw</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">(</span><span class=\"n\">unnorm_maw</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">invalid</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Normalize multiassignment weights from 0 to 1</span>\n            <span class=\"n\">masked_norm</span> <span class=\"o\">=</span> <span class=\"n\">masked_unorm_maw</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)[:,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">newaxis</span><span class=\"p\">]</span>\n            <span class=\"n\">masked_maw</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">divide</span><span class=\"p\">(</span><span class=\"n\">masked_unorm_maw</span><span class=\"p\">,</span> <span class=\"n\">masked_norm</span><span class=\"p\">)</span>\n            <span class=\"n\">masked_wxs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">invalid</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Just keep masked arrays as they are</span>\n            <span class=\"c1\"># (more efficient than python lists)</span>\n            <span class=\"n\">idx_to_wxs</span> <span class=\"o\">=</span> <span class=\"n\">masked_wxs</span>\n            <span class=\"n\">idx_to_maws</span> <span class=\"o\">=</span> <span class=\"n\">masked_maw</span>\n            <span class=\"c1\"># # Remove masked weights and word indexes</span>\n            <span class=\"c1\"># idx_to_wxs  = [np.array(ut.filter_Nones(wxs), dtype=np.int32)</span>\n            <span class=\"c1\">#                for wxs in masked_wxs.tolist()]</span>\n            <span class=\"c1\"># idx_to_maws = [np.array(ut.filter_Nones(maw), dtype=np.float32)</span>\n            <span class=\"c1\">#                for maw in masked_maw.tolist()]</span>\n    <span class=\"k\">return</span> <span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">idx_to_maws</span></div>\n\n\n<div class=\"viewcode-block\" id=\"assign_to_words\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.assign_to_words\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">assign_to_words</span><span class=\"p\">(</span><span class=\"n\">vocab</span><span class=\"p\">,</span> <span class=\"n\">idx_to_vec</span><span class=\"p\">,</span> <span class=\"n\">nAssign</span><span class=\"p\">,</span> <span class=\"n\">massign_alpha</span><span class=\"o\">=</span><span class=\"mf\">1.2</span><span class=\"p\">,</span>\n                    <span class=\"n\">massign_sigma</span><span class=\"o\">=</span><span class=\"mf\">80.0</span><span class=\"p\">,</span> <span class=\"n\">massign_equal_weights</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n                    <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Assigns descriptor-vectors to nearest word.</span>\n\n<span class=\"sd\">    Notes:</span>\n<span class=\"sd\">        Maybe move out of this file? The usage of vocab is out of this file</span>\n<span class=\"sd\">        scope.</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        wordflann (FLANN): nearest neighbor index over words</span>\n<span class=\"sd\">        words (ndarray): vocabulary words</span>\n<span class=\"sd\">        idx_to_vec (ndarray): descriptors to assign</span>\n<span class=\"sd\">        nAssign (int): number of words to assign each descriptor to</span>\n<span class=\"sd\">        massign_alpha (float): multiple-assignment ratio threshold</span>\n<span class=\"sd\">        massign_sigma (float): multiple-assignment gaussian variance</span>\n<span class=\"sd\">        massign_equal_weights (bool): assign equal weight to all multiassigned words</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        tuple: inverted index, multi-assigned weights, and forward index</span>\n<span class=\"sd\">        formated as::</span>\n\n<span class=\"sd\">            * wx_to_idxs - word index   -&gt; vector indexes</span>\n<span class=\"sd\">            * wx_to_maws - word index   -&gt; multi-assignment weights</span>\n<span class=\"sd\">            * idx2_wxs - vector index -&gt; assigned word indexes</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # SLOW_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; # xdoctest: +SKIP</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_vec = depc.d.get_feat_vecs(aid_list)[0][0::300]</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_vec = np.vstack((idx_to_vec, vocab.wx_to_word[0]))</span>\n<span class=\"sd\">        &gt;&gt;&gt; nAssign = 2</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_equal_weights = False</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_alpha = 1.2</span>\n<span class=\"sd\">        &gt;&gt;&gt; massign_sigma = 80.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; nAssign = 2</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs, idx_to_maws = assign_to_words(vocab, idx_to_vec, nAssign)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;idx_to_maws = %s&#39; % (ut.repr2(idx_to_wxs, precision=2),))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;idx_to_wxs = %s&#39; % (ut.repr2(idx_to_maws, precision=2),))</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">verbose</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span>\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[vocab.assign] +--- Start Assign vecs to words.&#39;</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[vocab.assign] * nAssign=</span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"n\">nAssign</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[vocab.assign] assign_to_words_. len(idx_to_vec) = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">idx_to_vec</span><span class=\"p\">))</span>\n    <span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">_idx_to_wdist</span> <span class=\"o\">=</span> <span class=\"n\">vocab</span><span class=\"o\">.</span><span class=\"n\">nn_index</span><span class=\"p\">(</span><span class=\"n\">idx_to_vec</span><span class=\"p\">,</span> <span class=\"n\">nAssign</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">nAssign</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">idx_to_maws</span> <span class=\"o\">=</span> <span class=\"n\">weight_multi_assigns</span><span class=\"p\">(</span>\n            <span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">_idx_to_wdist</span><span class=\"p\">,</span> <span class=\"n\">massign_alpha</span><span class=\"p\">,</span> <span class=\"n\">massign_sigma</span><span class=\"p\">,</span>\n            <span class=\"n\">massign_equal_weights</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># idx_to_wxs = _idx_to_wx.tolist()</span>\n        <span class=\"c1\"># idx_to_maws = [[1.0]] * len(idx_to_wxs)</span>\n        <span class=\"n\">idx_to_wxs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">(</span><span class=\"n\">_idx_to_wx</span><span class=\"p\">,</span> <span class=\"n\">fill_value</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">idx_to_maws</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">fill_value</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n                                 <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n        <span class=\"n\">idx_to_maws</span><span class=\"o\">.</span><span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">mask</span>\n    <span class=\"k\">return</span> <span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">idx_to_maws</span></div>\n\n\n<div class=\"viewcode-block\" id=\"invert_assigns_old\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.invert_assigns_old\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">invert_assigns_old</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">idx_to_maws</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Inverts assignment of vectors to words into words to vectors.</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs = [</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([0, 4], dtype=np.int32),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([2], dtype=np.int32),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([2, 0], dtype=np.int32),</span>\n<span class=\"sd\">        &gt;&gt;&gt; ]</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_maws = [</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([ 0.5,  0.5], dtype=np.float32),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([ 1.], dtype=np.float32),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     np.array([ 0.5,  0.5], dtype=np.float32),</span>\n<span class=\"sd\">        &gt;&gt;&gt; ]</span>\n<span class=\"sd\">        &gt;&gt;&gt; wx_to_idxs, wx_to_maws = invert_assigns_old(idx_to_wxs, idx_to_maws)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;wx_to_idxs = %s&#39; % (ut.repr4(wx_to_idxs, with_dtype=True),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result += &#39;\\nwx_to_maws = %s&#39; % (ut.repr4(wx_to_maws, with_dtype=True),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        wx_to_idxs = {</span>\n<span class=\"sd\">            0: np.array([0, 2], dtype=np.int32),</span>\n<span class=\"sd\">            2: np.array([1, 2], dtype=np.int32),</span>\n<span class=\"sd\">            4: np.array([0], dtype=np.int32),</span>\n<span class=\"sd\">        }</span>\n<span class=\"sd\">        wx_to_maws = {</span>\n<span class=\"sd\">            0: np.array([0.5, 0.5], dtype=np.float32),</span>\n<span class=\"sd\">            2: np.array([1. , 0.5], dtype=np.float32),</span>\n<span class=\"sd\">            4: np.array([0.5], dtype=np.float32),</span>\n<span class=\"sd\">        }</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Invert mapping -- Group by word indexes</span>\n    <span class=\"n\">idx_to_nAssign</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">wxs</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">wxs</span> <span class=\"ow\">in</span> <span class=\"n\">idx_to_wxs</span><span class=\"p\">]</span>\n    <span class=\"n\">jagged_idxs</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"n\">idx</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">num</span> <span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">num</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">idx_to_nAssign</span><span class=\"p\">)]</span>\n    <span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">jagged_group</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"p\">)</span>\n    <span class=\"n\">idxs_list</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_jagged_grouping</span><span class=\"p\">(</span><span class=\"n\">jagged_idxs</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span><span class=\"p\">)</span>\n    <span class=\"n\">idxs_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">idxs</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">idxs</span> <span class=\"ow\">in</span> <span class=\"n\">idxs_list</span><span class=\"p\">]</span>\n    <span class=\"n\">wx_to_idxs</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">idxs_list</span><span class=\"p\">))</span>\n    <span class=\"n\">maws_list</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_jagged_grouping</span><span class=\"p\">(</span><span class=\"n\">idx_to_maws</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span><span class=\"p\">)</span>\n    <span class=\"n\">maws_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">maws</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">maws</span> <span class=\"ow\">in</span> <span class=\"n\">maws_list</span><span class=\"p\">]</span>\n    <span class=\"n\">wx_to_maws</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">maws_list</span><span class=\"p\">))</span>\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[vocab] L___ End Assign vecs to words.&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">wx_to_idxs</span><span class=\"p\">,</span> <span class=\"n\">wx_to_maws</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"invert_assigns\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.invert_assigns\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">invert_assigns</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">idx_to_maws</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Inverts assignment of</span>\n<span class=\"sd\">    vectors-&gt;to-&gt;words into words-&gt;to-&gt;vectors.</span>\n<span class=\"sd\">    Invert mapping -- Group by word indexes</span>\n\n<span class=\"sd\">    This gives a HUGE speedup over the old invert_assigns</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs = np.ma.array([</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (0, 4),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (2, -1),</span>\n<span class=\"sd\">        &gt;&gt;&gt;     (2, 0)], dtype=np.int32)</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_wxs[1, 1] = np.ma.masked</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_maws = np.ma.array(</span>\n<span class=\"sd\">        &gt;&gt;&gt;     [(.5, 1.), (1., np.nan), (.5, .5)], dtype=np.float32)</span>\n<span class=\"sd\">        &gt;&gt;&gt; idx_to_maws[1, 1] = np.ma.masked</span>\n<span class=\"sd\">        &gt;&gt;&gt; tup = invert_assigns(idx_to_wxs, idx_to_maws)</span>\n<span class=\"sd\">        &gt;&gt;&gt; wx_to_idxs, wx_to_maws = tup</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;wx_to_idxs = %s&#39; % (ut.repr4(wx_to_idxs, with_dtype=True),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result += &#39;\\nwx_to_maws = %s&#39; % (ut.repr4(wx_to_maws, with_dtype=True),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        wx_to_idxs = {</span>\n<span class=\"sd\">            0: np.array([0, 2], dtype=np.int32),</span>\n<span class=\"sd\">            2: np.array([1, 2], dtype=np.int32),</span>\n<span class=\"sd\">            4: np.array([0], dtype=np.int32),</span>\n<span class=\"sd\">        }</span>\n<span class=\"sd\">        wx_to_maws = {</span>\n<span class=\"sd\">            0: np.array([0.5, 0.5], dtype=np.float32),</span>\n<span class=\"sd\">            2: np.array([1. , 0.5], dtype=np.float32),</span>\n<span class=\"sd\">            4: np.array([1.], dtype=np.float32),</span>\n<span class=\"sd\">        }</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">idx_to_maws</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ma</span><span class=\"o\">.</span><span class=\"n\">masked_array</span><span class=\"p\">)</span>\n\n    <span class=\"n\">nrows</span><span class=\"p\">,</span> <span class=\"n\">ncols</span> <span class=\"o\">=</span> <span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">valid_mask</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"n\">nrows</span><span class=\"p\">,</span> <span class=\"n\">ncols</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">bool</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">valid_mask</span> <span class=\"o\">=</span> <span class=\"o\">~</span><span class=\"n\">idx_to_maws</span><span class=\"o\">.</span><span class=\"n\">mask</span>\n        <span class=\"c1\"># idx_to_nAssign = (valid_mask).sum(axis=1)</span>\n\n    <span class=\"n\">_valid_x2d</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">flatnonzero</span><span class=\"p\">(</span><span class=\"n\">valid_mask</span><span class=\"p\">)</span>\n    <span class=\"n\">flat_idxs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">floor_divide</span><span class=\"p\">(</span><span class=\"n\">_valid_x2d</span><span class=\"p\">,</span> <span class=\"n\">ncols</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span>\n    <span class=\"n\">flat_wxs</span> <span class=\"o\">=</span> <span class=\"n\">idx_to_wxs</span><span class=\"o\">.</span><span class=\"n\">compressed</span><span class=\"p\">()</span>\n    <span class=\"n\">flat_maws</span> <span class=\"o\">=</span> <span class=\"n\">idx_to_maws</span><span class=\"o\">.</span><span class=\"n\">compressed</span><span class=\"p\">()</span>\n\n    <span class=\"n\">sortx</span> <span class=\"o\">=</span> <span class=\"n\">flat_wxs</span><span class=\"o\">.</span><span class=\"n\">argsort</span><span class=\"p\">()</span>\n    <span class=\"n\">flat_wxs</span> <span class=\"o\">=</span> <span class=\"n\">flat_wxs</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">sortx</span><span class=\"p\">)</span>\n    <span class=\"n\">flat_idxs</span> <span class=\"o\">=</span> <span class=\"n\">flat_idxs</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">sortx</span><span class=\"p\">)</span>\n    <span class=\"n\">flat_maws</span> <span class=\"o\">=</span> <span class=\"n\">flat_maws</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">sortx</span><span class=\"p\">)</span>\n\n    <span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">group_indices</span><span class=\"p\">(</span><span class=\"n\">flat_wxs</span><span class=\"p\">)</span>\n    <span class=\"n\">idxs_list</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_grouping</span><span class=\"p\">(</span><span class=\"n\">flat_idxs</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span><span class=\"p\">)</span>\n    <span class=\"n\">maws_list</span> <span class=\"o\">=</span> <span class=\"n\">vt</span><span class=\"o\">.</span><span class=\"n\">apply_grouping</span><span class=\"p\">(</span><span class=\"n\">flat_maws</span><span class=\"p\">,</span> <span class=\"n\">groupxs</span><span class=\"p\">)</span>\n\n    <span class=\"n\">wx_to_idxs</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">idxs_list</span><span class=\"p\">))</span>\n    <span class=\"n\">wx_to_maws</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">wx_keys</span><span class=\"p\">,</span> <span class=\"n\">maws_list</span><span class=\"p\">))</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[vocab] L___ End Assign vecs to words.&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">wx_to_idxs</span><span class=\"p\">,</span> <span class=\"n\">wx_to_maws</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"invert_lists\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.invert_lists\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">invert_lists</span><span class=\"p\">(</span><span class=\"n\">aids</span><span class=\"p\">,</span> <span class=\"n\">wx_lists</span><span class=\"p\">,</span> <span class=\"n\">all_wxs</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    takes corresponding lists of (aids, wxs) and maps wxs to aids</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; aids = [1, 2, 3]</span>\n<span class=\"sd\">        &gt;&gt;&gt; wx_lists = [[0, 1], [20, 0, 1], [3]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; wx_to_aids = invert_lists(aids, wx_lists)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = (&#39;wx_to_aids = %s&#39; % (ut.repr2(wx_to_aids),))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        wx_to_aids = {0: [1, 2], 1: [1, 2], 3: [3], 20: [2]}</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">all_wxs</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">wx_to_aids</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ddict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">wx_to_aids</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">wx</span><span class=\"p\">:</span> <span class=\"p\">[]</span> <span class=\"k\">for</span> <span class=\"n\">wx</span> <span class=\"ow\">in</span> <span class=\"n\">all_wxs</span><span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"n\">aid</span><span class=\"p\">,</span> <span class=\"n\">wxs</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">aids</span><span class=\"p\">,</span> <span class=\"n\">wx_lists</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">wx</span> <span class=\"ow\">in</span> <span class=\"n\">wxs</span><span class=\"p\">:</span>\n            <span class=\"n\">wx_to_aids</span><span class=\"p\">[</span><span class=\"n\">wx</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">aid</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">wx_to_aids</span></div>\n\n\n<div class=\"viewcode-block\" id=\"inv_doc_freq\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.inv_doc_freq\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">inv_doc_freq</span><span class=\"p\">(</span><span class=\"n\">ndocs_total</span><span class=\"p\">,</span> <span class=\"n\">ndocs_per_word</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        ndocs_total (int): numer of unique documents</span>\n<span class=\"sd\">        ndocs_per_word (ndarray): ndocs_per_word[i] should correspond to the</span>\n<span class=\"sd\">            number of unique documents containing word[i]</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        ndarrary: idf_per_word</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; ndocs_total = 21</span>\n<span class=\"sd\">        &gt;&gt;&gt; ndocs_per_word = [0, 21, 20, 2, 15, 8, 12, 1, 2]</span>\n<span class=\"sd\">        &gt;&gt;&gt; idf_per_word = inv_doc_freq(ndocs_total, ndocs_per_word)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;%s&#39; % (ut.repr2(idf_per_word, precision=2),)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        np.array([0.  , 0.  , 0.05, 2.35, 0.34, 0.97, 0.56, 3.04, 2.35])</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># We add epsilon to numer and denom to ensure recep is a probability</span>\n    <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">ndocs_per_word</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n    <span class=\"n\">out</span><span class=\"p\">[:]</span> <span class=\"o\">=</span> <span class=\"n\">ndocs_per_word</span>\n    <span class=\"c1\"># use jegou&#39;s version</span>\n    <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">divide</span><span class=\"p\">(</span><span class=\"n\">ndocs_total</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n    <span class=\"n\">idf_per_word</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n    <span class=\"n\">idf_per_word</span><span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">isinf</span><span class=\"p\">(</span><span class=\"n\">idf_per_word</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">return</span> <span class=\"n\">idf_per_word</span></div>\n    <span class=\"c1\"># if not adjust:</span>\n    <span class=\"c1\">#     # Typically for IDF, 1 is added to the denom to prevent divide by 0</span>\n    <span class=\"c1\">#     out[:] = ndocs_per_word</span>\n    <span class=\"c1\">#     ndocs_total += 1</span>\n    <span class=\"c1\"># else:</span>\n    <span class=\"c1\">#     # We add the 1 to the denominator and 2 to the numberator</span>\n    <span class=\"c1\">#     # to prevent words from receiving 0 weight</span>\n    <span class=\"c1\">#     out = np.add(ndocs_per_word, 1, out=out)</span>\n    <span class=\"c1\">#     ndocs_total += 2</span>\n    <span class=\"c1\"># out = np.divide(ndocs_total, out, out=out)</span>\n    <span class=\"c1\"># idf_per_word = np.log(out, out=out)</span>\n    <span class=\"c1\"># return idf_per_word</span>\n\n\n<div class=\"viewcode-block\" id=\"match_scores_agg\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.match_scores_agg\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">match_scores_agg</span><span class=\"p\">(</span><span class=\"n\">PhisX</span><span class=\"p\">,</span> <span class=\"n\">PhisY</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">flagsY</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Scores matches to multiple words using aggregate residual vectors</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; PhisX = np.array([[ 0.        ,  0.        ],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-1.        ,  0.        ],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [ 0.85085751,  0.52539652],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.89795083, -0.4400958 ],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.99934547,  0.03617512]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; PhisY = np.array([[ 0.88299408, -0.46938411],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.12096522, -0.99265675],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.99948266, -0.03216222],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.08394916, -0.99647004],</span>\n<span class=\"sd\">        &gt;&gt;&gt;                   [-0.96414952, -0.26535957]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; flagsX = np.array([True, False, False, True, False])[:, None]</span>\n<span class=\"sd\">        &gt;&gt;&gt; flagsY = np.array([False, False, False, True, False])[:, None]</span>\n<span class=\"sd\">        &gt;&gt;&gt; alpha = 3.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; thresh = 0.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; score_list = match_scores_agg(PhisX, PhisY, flagsX, flagsY, alpha, thresh)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = &#39;score_list = &#39; + ut.repr2(score_list, precision=4)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        score_list = np.array([1.    , 0.0018, 0.    , 1.    , 0.868 ])</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Can speedup aggregate with one vector per word assumption.</span>\n    <span class=\"c1\"># Take dot product between correponding VLAD vectors</span>\n    <span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">PhisX</span> <span class=\"o\">*</span> <span class=\"n\">PhisY</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Propogate error flags</span>\n    <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logical_or</span><span class=\"p\">(</span><span class=\"n\">flagsX</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">flagsY</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">flags</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">),</span> <span class=\"s1\">&#39;mismatch&#39;</span>\n    <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"n\">flags</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">score_list</span> <span class=\"o\">=</span> <span class=\"n\">selectivity</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">u</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">score_list</span></div>\n\n\n<div class=\"viewcode-block\" id=\"match_scores_sep\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.match_scores_sep\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">match_scores_sep</span><span class=\"p\">(</span><span class=\"n\">phisX_list</span><span class=\"p\">,</span> <span class=\"n\">phisY_list</span><span class=\"p\">,</span> <span class=\"n\">flagsX_list</span><span class=\"p\">,</span> <span class=\"n\">flagsY_list</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span>\n                     <span class=\"n\">thresh</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Scores matches to multiple words using lists of separeated residual vectors</span>\n\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">scores_list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"n\">_iter</span> <span class=\"o\">=</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">phisX_list</span><span class=\"p\">,</span> <span class=\"n\">phisY_list</span><span class=\"p\">,</span> <span class=\"n\">flagsX_list</span><span class=\"p\">,</span> <span class=\"n\">flagsY_list</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">phisX</span><span class=\"p\">,</span> <span class=\"n\">phisY</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">flagsY</span> <span class=\"ow\">in</span> <span class=\"n\">_iter</span><span class=\"p\">:</span>\n        <span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">phisX</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">phisY</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n        <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logical_or</span><span class=\"p\">(</span><span class=\"n\">flagsX</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">flagsY</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n        <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"n\">flags</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"n\">scores</span> <span class=\"o\">=</span> <span class=\"n\">selectivity</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">u</span><span class=\"p\">)</span>\n        <span class=\"n\">scores_list</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">scores</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">scores_list</span></div>\n\n\n<div class=\"viewcode-block\" id=\"build_matches_agg\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.build_matches_agg\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">build_matches_agg</span><span class=\"p\">(</span><span class=\"n\">X_fxs</span><span class=\"p\">,</span> <span class=\"n\">Y_fxs</span><span class=\"p\">,</span> <span class=\"n\">X_maws</span><span class=\"p\">,</span> <span class=\"n\">Y_maws</span><span class=\"p\">,</span> <span class=\"n\">score_list</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Builds explicit features matches. Break and distribute up each aggregate</span>\n<span class=\"sd\">    score amongst its contributing features.</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        tuple: (fm, fs)</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs build_matches_agg --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; map_int = ut.partial(ut.lmap, ut.partial(np.array, dtype=np.int32))</span>\n<span class=\"sd\">        &gt;&gt;&gt; map_float = ut.partial(ut.lmap, ut.partial(np.array, dtype=np.float32))</span>\n<span class=\"sd\">        &gt;&gt;&gt; X_fxs = map_int([[0, 1], [2, 3, 4], [5]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; Y_fxs = map_int([[8], [0, 4], [99]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; X_maws = map_float([[1, 1], [1, 1, 1], [1]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; Y_maws = map_float([[1], [1, 1], [1]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; score_list = np.array([1, 2, 3], dtype=np.float32)</span>\n<span class=\"sd\">        &gt;&gt;&gt; (fm, fs) = build_matches_agg(X_fxs, Y_fxs, X_maws, Y_maws, score_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;fm = &#39; + ut.repr2(fm))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;fs = &#39; + ut.repr2(fs))</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert len(fm) == len(fs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert score_list.sum() == fs.sum()</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Build feature matches</span>\n    <span class=\"c1\"># Spread word score according to contriubtion (maw) weight</span>\n    <span class=\"n\">unflat_contrib</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">maws1</span><span class=\"p\">[:,</span> <span class=\"kc\">None</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">maws2</span><span class=\"p\">[:,</span> <span class=\"kc\">None</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()</span>\n                      <span class=\"k\">for</span> <span class=\"n\">maws1</span><span class=\"p\">,</span> <span class=\"n\">maws2</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">X_maws</span><span class=\"p\">,</span> <span class=\"n\">Y_maws</span><span class=\"p\">)]</span>\n    <span class=\"n\">unflat_factor</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">contrib</span> <span class=\"o\">/</span> <span class=\"n\">contrib</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">contrib</span> <span class=\"ow\">in</span> <span class=\"n\">unflat_contrib</span><span class=\"p\">]</span>\n    <span class=\"c1\">#factor_list = np.divide(score_list, factor_list, out=factor_list)</span>\n    <span class=\"k\">for</span> <span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">factor</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">score_list</span><span class=\"p\">,</span> <span class=\"n\">unflat_factor</span><span class=\"p\">):</span>\n        <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">factor</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">factor</span><span class=\"p\">)</span>\n    <span class=\"n\">unflat_fs</span> <span class=\"o\">=</span> <span class=\"n\">unflat_factor</span>\n\n    <span class=\"c1\"># itertools.product seems fastest for small arrays</span>\n    <span class=\"n\">unflat_fm</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">product</span><span class=\"p\">(</span><span class=\"n\">fxs1</span><span class=\"p\">,</span> <span class=\"n\">fxs2</span><span class=\"p\">)</span>\n                 <span class=\"k\">for</span> <span class=\"n\">fxs1</span><span class=\"p\">,</span> <span class=\"n\">fxs2</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">X_fxs</span><span class=\"p\">,</span> <span class=\"n\">Y_fxs</span><span class=\"p\">))</span>\n\n    <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">unflat_fm</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span>\n    <span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">unflat_fs</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n    <span class=\"n\">isvalid</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">greater</span><span class=\"p\">(</span><span class=\"n\">fs</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">fm</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">isvalid</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">isvalid</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">fm</span><span class=\"p\">,</span> <span class=\"n\">fs</span></div>\n\n\n<div class=\"viewcode-block\" id=\"build_matches_sep\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.build_matches_sep\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">build_matches_sep</span><span class=\"p\">(</span><span class=\"n\">X_fxs</span><span class=\"p\">,</span> <span class=\"n\">Y_fxs</span><span class=\"p\">,</span> <span class=\"n\">scores_list</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Just build matches. Scores have already been broken up. No need to do that.</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        tuple: (fm, fs)</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs build_matches_agg --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; map_int = ut.partial(ut.lmap, ut.partial(np.array, dtype=np.int32))</span>\n<span class=\"sd\">        &gt;&gt;&gt; map_float = ut.partial(ut.lmap, ut.partial(np.array, dtype=np.float32))</span>\n<span class=\"sd\">        &gt;&gt;&gt; X_fxs = map_int([[0, 1], [2, 3, 4], [5]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; Y_fxs = map_int([[8], [0, 4], [99]])</span>\n<span class=\"sd\">        &gt;&gt;&gt; scores_list = map_float([</span>\n<span class=\"sd\">        &gt;&gt;&gt;     [[.1], [.2],],</span>\n<span class=\"sd\">        &gt;&gt;&gt;     [[.3, .4], [.4, .6], [.5, .9],],</span>\n<span class=\"sd\">        &gt;&gt;&gt;     [[.4]],</span>\n<span class=\"sd\">        &gt;&gt;&gt; ])</span>\n<span class=\"sd\">        &gt;&gt;&gt; (fm, fs) = build_matches_sep(X_fxs, Y_fxs, scores_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;fm = &#39; + ut.repr2(fm))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;fs = &#39; + ut.repr2(fs))</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert len(fm) == len(fs)</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert np.isclose(np.sum(ut.total_flatten(scores_list)), fs.sum())</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">total_flatten</span><span class=\"p\">(</span><span class=\"n\">scores_list</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n    <span class=\"n\">unflat_fm</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">product</span><span class=\"p\">(</span><span class=\"n\">fxs1</span><span class=\"p\">,</span> <span class=\"n\">fxs2</span><span class=\"p\">)</span>\n                 <span class=\"k\">for</span> <span class=\"n\">fxs1</span><span class=\"p\">,</span> <span class=\"n\">fxs2</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">X_fxs</span><span class=\"p\">,</span> <span class=\"n\">Y_fxs</span><span class=\"p\">))</span>\n    <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">unflat_fm</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span>\n    <span class=\"n\">isvalid</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">greater</span><span class=\"p\">(</span><span class=\"n\">fs</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">fm</span> <span class=\"o\">=</span> <span class=\"n\">fm</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">isvalid</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">fs</span> <span class=\"o\">=</span> <span class=\"n\">fs</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">isvalid</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">fm</span><span class=\"p\">,</span> <span class=\"n\">fs</span></div>\n\n\n<div class=\"viewcode-block\" id=\"gamma_agg\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.gamma_agg\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">gamma_agg</span><span class=\"p\">(</span><span class=\"n\">phisX</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">weight_list</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Computes gamma (self consistency criterion)</span>\n<span class=\"sd\">    It is a scalar which ensures K(X, X) = 1</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        float: sccw self-consistency-criterion weight</span>\n\n<span class=\"sd\">    Math:</span>\n<span class=\"sd\">        gamma(X) = (sum_{c in C} w_c M(X_c, X_c))^{-.5}</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_pipeline import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs, smk, qreq_= testdata_smk()</span>\n<span class=\"sd\">        &gt;&gt;&gt; X = qreq_.qinva.grouped_annots[0]</span>\n<span class=\"sd\">        &gt;&gt;&gt; wx_to_weight = qreq_.wx_to_weight</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(&#39;X.gamma = %r&#39; % (gamma(X),))</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">scores</span> <span class=\"o\">=</span> <span class=\"n\">match_scores_agg</span><span class=\"p\">(</span><span class=\"n\">phisX</span><span class=\"p\">,</span> <span class=\"n\">phisX</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">)</span>\n    <span class=\"n\">sccw</span> <span class=\"o\">=</span> <span class=\"n\">sccw_normalize</span><span class=\"p\">(</span><span class=\"n\">scores</span><span class=\"p\">,</span> <span class=\"n\">weight_list</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">sccw</span></div>\n\n\n<div class=\"viewcode-block\" id=\"gamma_sep\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.gamma_sep\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">gamma_sep</span><span class=\"p\">(</span><span class=\"n\">phisX_list</span><span class=\"p\">,</span> <span class=\"n\">flagsX_list</span><span class=\"p\">,</span> <span class=\"n\">weight_list</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">):</span>\n    <span class=\"n\">scores_list</span> <span class=\"o\">=</span> <span class=\"n\">match_scores_sep</span><span class=\"p\">(</span><span class=\"n\">phisX_list</span><span class=\"p\">,</span> <span class=\"n\">phisX_list</span><span class=\"p\">,</span> <span class=\"n\">flagsX_list</span><span class=\"p\">,</span>\n                                   <span class=\"n\">flagsX_list</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">)</span>\n    <span class=\"n\">scores</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">scores</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">scores</span> <span class=\"ow\">in</span> <span class=\"n\">scores_list</span><span class=\"p\">])</span>\n    <span class=\"n\">sccw</span> <span class=\"o\">=</span> <span class=\"n\">sccw_normalize</span><span class=\"p\">(</span><span class=\"n\">scores</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">sccw</span></div>\n\n\n<div class=\"viewcode-block\" id=\"sccw_normalize\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.sccw_normalize\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">sccw_normalize</span><span class=\"p\">(</span><span class=\"n\">scores</span><span class=\"p\">,</span> <span class=\"n\">weight_list</span><span class=\"p\">):</span>\n    <span class=\"n\">scores</span> <span class=\"o\">*=</span> <span class=\"n\">weight_list</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">scores</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span>\n    <span class=\"n\">sccw</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">reciprocal</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">sccw</span></div>\n\n\n<div class=\"viewcode-block\" id=\"selective_match_score\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.selective_match_score\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">selective_match_score</span><span class=\"p\">(</span><span class=\"n\">phisX</span><span class=\"p\">,</span> <span class=\"n\">phisY</span><span class=\"p\">,</span> <span class=\"n\">flagsX</span><span class=\"p\">,</span> <span class=\"n\">flagsY</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    computes the score of each feature match</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">phisX</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">phisY</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Give error flags full scores. These are typically distinctive and</span>\n    <span class=\"c1\"># important cases without enough info to get residual data.</span>\n    <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">logical_or</span><span class=\"p\">(</span><span class=\"n\">flagsX</span><span class=\"p\">[:,</span> <span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"n\">flagsY</span><span class=\"p\">)</span>\n    <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"n\">flags</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">selectivity</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">u</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">score</span></div>\n\n\n<div class=\"viewcode-block\" id=\"selectivity\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.selectivity\">[docs]</a><span class=\"nd\">@profile</span>\n<span class=\"k\">def</span> <span class=\"nf\">selectivity</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">3.0</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    The selectivity function thresholds and applies a power law.</span>\n\n<span class=\"sd\">    This downweights weak matches.</span>\n<span class=\"sd\">    The following is the exact definition from SMK paper.</span>\n<span class=\"sd\">    sigma_alpha(u) = (sign(u) * (u ** alpha) if u &gt; thresh else 0)</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        u (ndarray): input score between (-1, +1)</span>\n<span class=\"sd\">        alpha (float): power law (default = 3.0)</span>\n<span class=\"sd\">        thresh (float): number between 0 and 1 (default = 0.0)</span>\n<span class=\"sd\">        out (None): inplace output (default = None)</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        float: score</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m plottool plot_func --show --range=-1,1  \\</span>\n<span class=\"sd\">            --setup=&quot;import ibeis&quot; \\</span>\n<span class=\"sd\">            --func ibeis.algo.smk.smk_funcs.selectivity \\</span>\n<span class=\"sd\">            &quot;lambda u: sign(u) * abs(u)**3.0 * greater_equal(u, 0)&quot;</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs selectivity --show</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; u = np.array([-1.0, -.5, -.1, 0, .1, .5, 1.0])</span>\n<span class=\"sd\">        &gt;&gt;&gt; alpha = 3.0</span>\n<span class=\"sd\">        &gt;&gt;&gt; thresh = 0</span>\n<span class=\"sd\">        &gt;&gt;&gt; score = selectivity(u, alpha, thresh)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = ut.repr2(score.tolist(), precision=4)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        [0.0000, 0.0000, 0.0000, 0.0000, 0.0010, 0.1250, 1.0000]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">u</span>\n    <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">less</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">thresh</span><span class=\"p\">)</span>\n    <span class=\"n\">isign</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sign</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">)</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">power</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n    <span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">multiply</span><span class=\"p\">(</span><span class=\"n\">isign</span><span class=\"p\">,</span> <span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"o\">=</span><span class=\"n\">out</span><span class=\"p\">)</span>\n    <span class=\"n\">score</span><span class=\"p\">[</span><span class=\"n\">flags</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\">#score = np.sign(u) * np.power(np.abs(u), alpha)</span>\n    <span class=\"c1\">#score *= flags</span>\n    <span class=\"k\">return</span> <span class=\"n\">score</span></div>\n\n\n<div class=\"viewcode-block\" id=\"testdata_rvecs\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.smk/#ibeis.algo.smk.smk_funcs.testdata_rvecs\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">testdata_rvecs</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">nvecs</span><span class=\"o\">=</span><span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"n\">nwords</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">nannots</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    two dimensional test data</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs testdata_rvecs --show</span>\n\n<span class=\"sd\">    Ignore:</span>\n<span class=\"sd\">        dim = 2</span>\n<span class=\"sd\">        nvecs = 13</span>\n<span class=\"sd\">        nwords = 5</span>\n<span class=\"sd\">        nannots = 5</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.smk.smk_funcs import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; data = testdata_rvecs()</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.quit_if_noshow()</span>\n<span class=\"sd\">        &gt;&gt;&gt; exec(ut.execstr_dict(data))</span>\n<span class=\"sd\">        &gt;&gt;&gt; import plottool as pt</span>\n<span class=\"sd\">        &gt;&gt;&gt; from scipy.spatial import Voronoi, voronoi_plot_2d</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.qt4ensure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; fig = pt.figure()</span>\n<span class=\"sd\">        &gt;&gt;&gt; vor = Voronoi(words)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(words.T[0], words.T[1], &#39;r*&#39;, label=&#39;words&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(vecs.T[0], vecs.T[1], &#39;b.&#39;, label=&#39;vecs&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # lines showing assignments (and residuals)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pts1 = vecs</span>\n<span class=\"sd\">        &gt;&gt;&gt; pts2 = words[idx_to_wx.T[0]]</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.draw_line_segments2(pts1, pts2)</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plot(vecs.T[0], vecs.T[1], &#39;g.&#39;, label=&#39;vecs&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; voronoi_plot_2d(vor, show_vertices=False, ax=pt.gca())</span>\n<span class=\"sd\">        &gt;&gt;&gt; extents = vt.get_pointset_extents(np.vstack((vecs, words)))</span>\n<span class=\"sd\">        &gt;&gt;&gt; extents = vt.scale_extents(extents, 1.1)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ax = pt.gca()</span>\n<span class=\"sd\">        &gt;&gt;&gt; ax.set_aspect(&#39;equal&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ax.set_xlim(*extents[0:2])</span>\n<span class=\"sd\">        &gt;&gt;&gt; ax.set_ylim(*extents[2:4])</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.show_if_requested()</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">sklearn.metrics.pairwise</span> <span class=\"k\">import</span> <span class=\"n\">euclidean_distances</span>\n    <span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n    <span class=\"c1\">#dim = dim</span>\n    <span class=\"c1\"># nvecs = 13</span>\n    <span class=\"c1\"># nwords = 5</span>\n    <span class=\"n\">words</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">nwords</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">)</span>\n    <span class=\"n\">vecs</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">rand</span><span class=\"p\">(</span><span class=\"n\">nvecs</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Create vector = word special case</span>\n    <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>\n    <span class=\"n\">vecs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>\n    <span class=\"c1\"># Create aggregate canceling special case</span>\n    <span class=\"c1\"># TODO: ensure no other words are closer</span>\n    <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>\n    <span class=\"n\">vecs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span>\n    <span class=\"n\">vecs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.2</span>\n    <span class=\"n\">vecs</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">2.2</span>\n    <span class=\"c1\">#vt.normalize(words, axis=1, inplace=True)</span>\n    <span class=\"c1\">#vt.normalize(vecs, axis=1, inplace=True)</span>\n    <span class=\"n\">dist_mat</span> <span class=\"o\">=</span> <span class=\"n\">euclidean_distances</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">)</span>\n    <span class=\"n\">nAssign</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">sortx2d</span> <span class=\"o\">=</span> <span class=\"n\">dist_mat</span><span class=\"o\">.</span><span class=\"n\">argsort</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">row_offset</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">sortx2d</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])[:,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>\n    <span class=\"n\">sortx1d</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">row_offset</span> <span class=\"o\">*</span> <span class=\"n\">sortx2d</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">sortx2d</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()</span>\n    <span class=\"n\">idx_to_dist</span> <span class=\"o\">=</span> <span class=\"n\">dist_mat</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"n\">sortx1d</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">sortx2d</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)[:,</span> <span class=\"p\">:</span><span class=\"n\">nAssign</span><span class=\"p\">]</span>\n    <span class=\"n\">idx_to_wx</span> <span class=\"o\">=</span> <span class=\"n\">sortx2d</span><span class=\"p\">[:,</span> <span class=\"p\">:</span><span class=\"n\">nAssign</span><span class=\"p\">]</span>\n    <span class=\"n\">rvecs</span><span class=\"p\">,</span> <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"n\">compute_rvec</span><span class=\"p\">(</span><span class=\"n\">vecs</span><span class=\"p\">,</span> <span class=\"n\">words</span><span class=\"p\">[</span><span class=\"n\">idx_to_wx</span><span class=\"o\">.</span><span class=\"n\">T</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]])</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">nannots</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">nannots</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"n\">nvecs</span><span class=\"p\">)</span>\n    <span class=\"n\">offset_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">nvecs</span><span class=\"p\">,</span> <span class=\"n\">nannots</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"n\">nvecs</span><span class=\"p\">]</span>\n    <span class=\"c1\"># nfeat_list = np.diff(offset_list)</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"s1\">&#39;idx_to_dist&#39;</span><span class=\"p\">:</span> <span class=\"n\">idx_to_dist</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;idx_to_wx&#39;</span><span class=\"p\">:</span> <span class=\"n\">idx_to_wx</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;rvecs&#39;</span><span class=\"p\">:</span> <span class=\"n\">rvecs</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;vecs&#39;</span><span class=\"p\">:</span> <span class=\"n\">vecs</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;words&#39;</span><span class=\"p\">:</span> <span class=\"n\">words</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;flags&#39;</span><span class=\"p\">:</span> <span class=\"n\">flags</span><span class=\"p\">,</span>\n        <span class=\"s1\">&#39;offset_list&#39;</span><span class=\"p\">:</span> <span class=\"n\">offset_list</span><span class=\"p\">,</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">data</span></div>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs</span>\n<span class=\"sd\">        python -m ibeis.algo.smk.smk_funcs --allexamples</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">multiprocessing</span>\n    <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">freeze_support</span><span class=\"p\">()</span>  <span class=\"c1\"># for win32</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>  <span class=\"c1\"># NOQA</span>\n    <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">doctest_funcs</span><span class=\"p\">()</span>\n</pre></div>", "current_page_name": "_modules/ibeis/algo/smk/smk_funcs", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}