{"parents": [{"link": "../../../../", "title": "Module code"}, {"link": "../../../", "title": "ibeis"}, {"link": "../../", "title": "ibeis.algo"}, {"link": "../", "title": "ibeis.algo.hots"}], "title": "ibeis.algo.hots.neighbor_index_cache", "body": "<h1>Source code for ibeis.algo.hots.neighbor_index_cache</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">NEEDS CLEANUP</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"k\">import</span> <span class=\"n\">absolute_import</span><span class=\"p\">,</span> <span class=\"n\">division</span><span class=\"p\">,</span> <span class=\"n\">print_function</span>\n<span class=\"kn\">from</span> <span class=\"nn\">os.path</span> <span class=\"k\">import</span> <span class=\"n\">join</span>\n<span class=\"kn\">import</span> <span class=\"nn\">six</span>\n<span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>\n<span class=\"kn\">from</span> <span class=\"nn\">six.moves</span> <span class=\"k\">import</span> <span class=\"nb\">range</span><span class=\"p\">,</span> <span class=\"nb\">zip</span><span class=\"p\">,</span> <span class=\"nb\">map</span>  <span class=\"c1\"># NOQA</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ibeis.algo.hots</span> <span class=\"k\">import</span> <span class=\"n\">_pipeline_helpers</span> <span class=\"k\">as</span> <span class=\"n\">plh</span>  <span class=\"c1\"># NOQA</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ibeis.algo.hots.neighbor_index</span> <span class=\"k\">import</span> <span class=\"n\">NeighborIndex</span><span class=\"p\">,</span> <span class=\"n\">get_support_data</span>\n<span class=\"p\">(</span><span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"n\">rrr</span><span class=\"p\">,</span> <span class=\"n\">profile</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">inject2</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">USE_HOTSPOTTER_CACHE</span> <span class=\"o\">=</span> <span class=\"ow\">not</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_argflag</span><span class=\"p\">(</span><span class=\"s1\">&#39;--nocache-hs&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">NOCACHE_UUIDS</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_argflag</span><span class=\"p\">(</span><span class=\"s1\">&#39;--nocache-uuids&#39;</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">USE_HOTSPOTTER_CACHE</span>\n\n<span class=\"c1\"># LRU cache for nn_indexers. Ensures that only a few are ever in memory</span>\n<span class=\"c1\">#MAX_NEIGHBOR_CACHE_SIZE = ut.get_argval(&#39;--max-neighbor-cachesize&#39;, type_=int, default=2)</span>\n<span class=\"n\">MAX_NEIGHBOR_CACHE_SIZE</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_argval</span><span class=\"p\">(</span><span class=\"s1\">&#39;--max-neighbor-cachesize&#39;</span><span class=\"p\">,</span> <span class=\"n\">type_</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\"># Background process for building indexes</span>\n<span class=\"n\">CURRENT_THREAD</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"c1\"># Global map to keep track of UUID lists with prebuild indexers.</span>\n<span class=\"n\">UUID_MAP</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ddict</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">)</span>\n<span class=\"n\">NEIGHBOR_CACHE</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_lru_cache</span><span class=\"p\">(</span><span class=\"n\">MAX_NEIGHBOR_CACHE_SIZE</span><span class=\"p\">)</span>\n\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache\">[docs]</a><span class=\"k\">class</span> <span class=\"nc\">UUIDMapHyrbridCache</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Class that lets multiple ways of writing to the uuid_map</span>\n<span class=\"sd\">    be swapped in and out interchangably</span>\n\n<span class=\"sd\">    TODO: the global read / write should periodically sync itself to disk and it</span>\n<span class=\"sd\">    should be loaded from disk initially</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">uuid_maps</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">ddict</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">)</span>\n        <span class=\"c1\">#self.uuid_map_fpath = uuid_map_fpath</span>\n        <span class=\"c1\">#self.init(uuid_map_fpath, min_reindex_thresh)</span>\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache.init\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache.init\">[docs]</a>    <span class=\"k\">def</span> <span class=\"nf\">init</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">args</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">kwargs</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span>\n        <span class=\"c1\">#self.read_func  = self.read_uuid_map_cpkl</span>\n        <span class=\"c1\">#self.write_func = self.write_uuid_map_cpkl</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_func</span>  <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">read_uuid_map_dict</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">write_func</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">write_uuid_map_dict</span></div>\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache.dump\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache.dump\">[docs]</a>    <span class=\"k\">def</span> <span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">cachedir</span><span class=\"p\">):</span>\n        <span class=\"c1\"># TODO: DUMP AND LOAD THIS HYBRID CACHE TO DISK</span>\n        <span class=\"c1\">#write_uuid_map_cpkl</span>\n        <span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uuid_maps_hybrid_cache.cPkl&#39;</span>\n        <span class=\"n\">cpkl_fpath</span> <span class=\"o\">=</span> <span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">fname</span><span class=\"p\">)</span>\n        <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">lock_and_save_cPkl</span><span class=\"p\">(</span><span class=\"n\">cpkl_fpath</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">uuid_maps</span><span class=\"p\">)</span></div>\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache.load\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache.load\">[docs]</a>    <span class=\"k\">def</span> <span class=\"nf\">load</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">cachedir</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        Returns a cache UUIDMap</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"n\">fname</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uuid_maps_hybrid_cache.cPkl&#39;</span>\n        <span class=\"n\">cpkl_fpath</span> <span class=\"o\">=</span> <span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">fname</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">uuid_maps</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">lock_and_load_cPkl</span><span class=\"p\">(</span><span class=\"n\">cpkl_fpath</span><span class=\"p\">)</span></div>\n\n    <span class=\"c1\">#def __call__(self):</span>\n    <span class=\"c1\">#    return  self.read_func(*self.args, **self.kwargs)</span>\n\n    <span class=\"c1\">#def __setitem__(self, daids_hashid, visual_uuid_list):</span>\n    <span class=\"c1\">#    uuid_map_fpath = self.uuid_map_fpath</span>\n    <span class=\"c1\">#    self.write_func(uuid_map_fpath, visual_uuid_list, daids_hashid)</span>\n\n    <span class=\"c1\">#@profile</span>\n    <span class=\"c1\">#def read_uuid_map_shelf(self, uuid_map_fpath, min_reindex_thresh):</span>\n    <span class=\"c1\">#    #with ut.EmbedOnException():</span>\n    <span class=\"c1\">#    with lockfile.LockFile(uuid_map_fpath + &#39;.lock&#39;):</span>\n    <span class=\"c1\">#        with ut.shelf_open(uuid_map_fpath) as uuid_map:</span>\n    <span class=\"c1\">#            candidate_uuids = {</span>\n    <span class=\"c1\">#                key: val for key, val in six.iteritems(uuid_map)</span>\n    <span class=\"c1\">#                if len(val) &gt;= min_reindex_thresh</span>\n    <span class=\"c1\">#            }</span>\n    <span class=\"c1\">#    return candidate_uuids</span>\n\n    <span class=\"c1\">#@profile</span>\n    <span class=\"c1\">#def write_uuid_map_shelf(self, uuid_map_fpath, visual_uuid_list, daids_hashid):</span>\n    <span class=\"c1\">#    print(&#39;Writing %d visual uuids to uuid map&#39; % (len(visual_uuid_list)))</span>\n    <span class=\"c1\">#    with lockfile.LockFile(uuid_map_fpath + &#39;.lock&#39;):</span>\n    <span class=\"c1\">#        with ut.shelf_open(uuid_map_fpath) as uuid_map:</span>\n    <span class=\"c1\">#            uuid_map[daids_hashid] = visual_uuid_list</span>\n\n    <span class=\"c1\">#@profile</span>\n    <span class=\"c1\">#def read_uuid_map_cpkl(self, uuid_map_fpath, min_reindex_thresh):</span>\n    <span class=\"c1\">#    with lockfile.LockFile(uuid_map_fpath + &#39;.lock&#39;):</span>\n    <span class=\"c1\">#        #with ut.shelf_open(uuid_map_fpath) as uuid_map:</span>\n    <span class=\"c1\">#        try:</span>\n    <span class=\"c1\">#            uuid_map = ut.load_cPkl(uuid_map_fpath)</span>\n    <span class=\"c1\">#            candidate_uuids = {</span>\n    <span class=\"c1\">#                key: val for key, val in six.iteritems(uuid_map)</span>\n    <span class=\"c1\">#                if len(val) &gt;= min_reindex_thresh</span>\n    <span class=\"c1\">#            }</span>\n    <span class=\"c1\">#        except IOError:</span>\n    <span class=\"c1\">#            return {}</span>\n    <span class=\"c1\">#    return candidate_uuids</span>\n\n    <span class=\"c1\">#@profile</span>\n    <span class=\"c1\">#def write_uuid_map_cpkl(self, uuid_map_fpath, visual_uuid_list, daids_hashid):</span>\n    <span class=\"c1\">#    &quot;&quot;&quot;</span>\n    <span class=\"c1\">#    let the multi-indexer know about any big caches we&#39;ve made multi-indexer.</span>\n    <span class=\"c1\">#    Also lets nnindexer know about other prebuilt indexers so it can attempt to</span>\n    <span class=\"c1\">#    just add points to them as to avoid a rebuild.</span>\n    <span class=\"c1\">#    &quot;&quot;&quot;</span>\n    <span class=\"c1\">#    print(&#39;Writing %d visual uuids to uuid map&#39; % (len(visual_uuid_list)))</span>\n    <span class=\"c1\">#    with lockfile.LockFile(uuid_map_fpath + &#39;.lock&#39;):</span>\n    <span class=\"c1\">#        try:</span>\n    <span class=\"c1\">#            uuid_map = ut.load_cPkl(uuid_map_fpath)</span>\n    <span class=\"c1\">#        except IOError:</span>\n    <span class=\"c1\">#            uuid_map = {}</span>\n    <span class=\"c1\">#        uuid_map[daids_hashid] = visual_uuid_list</span>\n    <span class=\"c1\">#        ut.save_cPkl(uuid_map_fpath, uuid_map)</span>\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache.read_uuid_map_dict\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache.read_uuid_map_dict\">[docs]</a>    <span class=\"nd\">@profile</span>\n    <span class=\"k\">def</span> <span class=\"nf\">read_uuid_map_dict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; uses in memory dictionary instead of disk &quot;&quot;&quot;</span>\n        <span class=\"n\">uuid_map</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">uuid_maps</span><span class=\"p\">[</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">]</span>\n        <span class=\"n\">candidate_uuids</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"n\">val</span> <span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">six</span><span class=\"o\">.</span><span class=\"n\">iteritems</span><span class=\"p\">(</span><span class=\"n\">uuid_map</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">min_reindex_thresh</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">candidate_uuids</span></div>\n\n<div class=\"viewcode-block\" id=\"UUIDMapHyrbridCache.write_uuid_map_dict\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.UUIDMapHyrbridCache.write_uuid_map_dict\">[docs]</a>    <span class=\"nd\">@profile</span>\n    <span class=\"k\">def</span> <span class=\"nf\">write_uuid_map_dict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        uses in memory dictionary instead of disk</span>\n\n<span class=\"sd\">        let the multi-indexer know about any big caches we&#39;ve made multi-indexer.</span>\n<span class=\"sd\">        Also lets nnindexer know about other prebuilt indexers so it can attempt to</span>\n<span class=\"sd\">        just add points to them as to avoid a rebuild.</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">if</span> <span class=\"n\">NOCACHE_UUIDS</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;uuid cache is off&#39;</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span>\n        <span class=\"c1\">#with ut.EmbedOnException():</span>\n        <span class=\"n\">uuid_map</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">uuid_maps</span><span class=\"p\">[</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">]</span>\n        <span class=\"n\">uuid_map</span><span class=\"p\">[</span><span class=\"n\">daids_hashid</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">visual_uuid_list</span></div></div>\n\n\n<span class=\"n\">UUID_MAP_CACHE</span> <span class=\"o\">=</span> <span class=\"n\">UUIDMapHyrbridCache</span><span class=\"p\">()</span>\n\n\n<span class=\"c1\">#@profile</span>\n<div class=\"viewcode-block\" id=\"get_nnindexer_uuid_map_fpath\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.get_nnindexer_uuid_map_fpath\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache get_nnindexer_uuid_map_fpath</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibeis.testdata_qreq_(defaultdb=&#39;testdb1&#39;, p=&#39;default:fgw_thresh=.3&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; uuid_map_fpath = get_nnindexer_uuid_map_fpath(qreq_)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(ut.path_ndir_split(uuid_map_fpath, 3))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n\n<span class=\"sd\">        .../_ibeis_cache/flann/uuid_map_mzwwsbjisbkdxorl.cPkl</span>\n<span class=\"sd\">        .../_ibeis_cache/flann/uuid_map_FLANN(8_kdtrees_fgwthrsh=0.3)_Feat(hesaff+sift)_Chip(sz700,width).cPkl</span>\n<span class=\"sd\">        .../_ibeis_cache/flann/uuid_map_FLANN(8_kdtrees)_Feat(hesaff+sift)_Chip(sz700,width).cPkl</span>\n<span class=\"sd\">        .../_ibeis_cache/flann/uuid_map_FLANN(8_kdtrees)_FEAT(hesaff+sift_)_CHIP(sz450).cPkl</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">flann_cachedir</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_flann_cachedir</span><span class=\"p\">()</span>\n    <span class=\"c1\"># Have uuid shelf conditioned on the baseline flann and feature parameters</span>\n    <span class=\"n\">flann_cfgstr</span>    <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">flann_cfgstr</span>\n    <span class=\"n\">feat_cfgstr</span>     <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">feat_cfgstr</span>\n    <span class=\"n\">chip_cfgstr</span>     <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">chip_cfgstr</span>\n    <span class=\"n\">featweight_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">featweight_cfgstr</span>\n    <span class=\"k\">if</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">fgw_thresh</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">or</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">fgw_thresh</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">uuid_map_cfgstr</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">((</span><span class=\"n\">flann_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">feat_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">chip_cfgstr</span><span class=\"p\">))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">uuid_map_cfgstr</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">((</span><span class=\"n\">flann_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">featweight_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">feat_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">chip_cfgstr</span><span class=\"p\">))</span>\n    <span class=\"c1\">#uuid_map_ext    = &#39;.shelf&#39;</span>\n    <span class=\"n\">uuid_map_ext</span>    <span class=\"o\">=</span> <span class=\"s1\">&#39;.cPkl&#39;</span>\n    <span class=\"n\">uuid_map_prefix</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uuid_map&#39;</span>\n    <span class=\"n\">uuid_map_fname</span>  <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">consensed_cfgstr</span><span class=\"p\">(</span><span class=\"n\">uuid_map_prefix</span><span class=\"p\">,</span> <span class=\"n\">uuid_map_cfgstr</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">uuid_map_ext</span>\n    <span class=\"n\">uuid_map_fpath</span>  <span class=\"o\">=</span> <span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">flann_cachedir</span><span class=\"p\">,</span> <span class=\"n\">uuid_map_fname</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">uuid_map_fpath</span></div>\n\n\n<div class=\"viewcode-block\" id=\"build_nnindex_cfgstr\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.build_nnindex_cfgstr\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">build_nnindex_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    builds a string that  uniquely identified an indexer built with parameters</span>\n<span class=\"sd\">    from the input query requested and indexing descriptor from the input</span>\n<span class=\"sd\">    annotation ids</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        qreq_ (QueryRequest):  query request object with hyper-parameters</span>\n<span class=\"sd\">        daid_list (list):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        str: nnindex_cfgstr</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-build_nnindex_cfgstr</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(db=&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ibeis.const.TEST_SPECIES.ZEB_PLAIN)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list, cfgdict=dict(fg_on=False))</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindex_cfgstr = build_nnindex_cfgstr(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(nnindex_cfgstr)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n\n<span class=\"sd\">        _VUUIDS((6)ylydksaqdigdecdd)_FLANN(8_kdtrees)_FeatureWeight(detector=cnn,sz256,thresh=20,ksz=20,enabled=False)_FeatureWeight(detector=cnn,sz256,thresh=20,ksz=20,enabled=False)</span>\n\n<span class=\"sd\">        _VUUIDS((6)ylydksaqdigdecdd)_FLANN(8_kdtrees)_FEATWEIGHT(OFF)_FEAT(hesaff+sift_)_CHIP(sz450)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">flann_cfgstr</span>      <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">flann_cfgstr</span>\n    <span class=\"n\">featweight_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">featweight_cfgstr</span>\n    <span class=\"n\">feat_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">feat_cfgstr</span>\n    <span class=\"n\">chip_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">chip_cfgstr</span>\n    <span class=\"c1\"># FIXME; need to include probchip (or better yet just use depcache)</span>\n    <span class=\"c1\">#probchip_cfgstr = qreq_.qparams.chip_cfgstr</span>\n    <span class=\"n\">data_hashid</span>   <span class=\"o\">=</span> <span class=\"n\">get_data_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">nnindex_cfgstr</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">((</span><span class=\"n\">data_hashid</span><span class=\"p\">,</span> <span class=\"n\">flann_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">featweight_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">feat_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">chip_cfgstr</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindex_cfgstr</span></div>\n\n\n<div class=\"viewcode-block\" id=\"clear_memcache\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.clear_memcache\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">clear_memcache</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">NEIGHBOR_CACHE</span>\n    <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"o\">.</span><span class=\"n\">clear</span><span class=\"p\">()</span></div>\n\n\n<div class=\"viewcode-block\" id=\"clear_uuid_cache\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.clear_uuid_cache\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">clear_uuid_cache</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-clear_uuid_cache</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibeis.testdata_qreq_(defaultdb=&#39;testdb1&#39;, p=&#39;default:fg_on=True&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; fgws_list = clear_uuid_cache(qreq_)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(fgws_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex] clearing uuid cache&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">uuid_map_fpath</span> <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n    <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">)</span>\n    <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;.lock&#39;</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex] finished uuid cache clear&#39;</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"print_uuid_cache\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.print_uuid_cache\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">print_uuid_cache</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-print_uuid_cache</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibeis.testdata_qreq_(defaultdb=&#39;PZ_Master0&#39;, p=&#39;default:fg_on=False&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print_uuid_cache(qreq_)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(nnindexer)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex] clearing uuid cache&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">uuid_map_fpath</span> <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n    <span class=\"n\">candidate_uuids</span> <span class=\"o\">=</span> <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">read_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">candidate_uuids</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"request_ibeis_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.request_ibeis_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">request_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CALLED BY QUERYREQUST::LOAD_INDEXER</span>\n<span class=\"sd\">    IBEIS interface into neighbor_index_cache</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        qreq_ (QueryRequest): hyper-parameters</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        NeighborIndexer: nnindexer</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache request_ibeis_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer, qreq_, ibs = testdata_nnindexer(None)</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_ibeis_nnindexer(qreq_)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">daid_list</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">get_internal_daids</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"p\">,</span> <span class=\"s1\">&#39;use_augmented_indexer&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">use_augmented_indexer</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"k\">if</span> <span class=\"kc\">False</span> <span class=\"ow\">and</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">use_augmented_indexer</span><span class=\"p\">:</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_augmented_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_memcached_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindexer</span></div>\n\n\n<div class=\"viewcode-block\" id=\"request_augmented_ibeis_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.request_augmented_ibeis_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">request_augmented_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                                      <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n                                      <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    DO NOT USE. THIS FUNCTION CAN CURRENTLY CAUSE A SEGFAULT</span>\n\n<span class=\"sd\">    tries to give you an indexer for the requested daids using the least amount</span>\n<span class=\"sd\">    of computation possible. By loading and adding to a partially build nnindex</span>\n<span class=\"sd\">    if possible and if that fails fallbs back to request_memcache.</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        qreq_ (QueryRequest):  query request object with hyper-parameters</span>\n<span class=\"sd\">        daid_list (list):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        str: nnindex_cfgstr</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-request_augmented_ibeis_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; # build test data</span>\n<span class=\"sd\">        &gt;&gt;&gt; ZEB_PLAIN = ibeis.const.TEST_SPECIES.ZEB_PLAIN</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; use_memcache, max_covers, verbose = True, None, True</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ZEB_PLAIN)[0:6]</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_.qparams.min_reindex_thresh = 1</span>\n<span class=\"sd\">        &gt;&gt;&gt; min_reindex_thresh = qreq_.qparams.min_reindex_thresh</span>\n<span class=\"sd\">        &gt;&gt;&gt; # CLEAR CACHE for clean test</span>\n<span class=\"sd\">        &gt;&gt;&gt; clear_uuid_cache(qreq_)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # LOAD 3 AIDS INTO CACHE</span>\n<span class=\"sd\">        &gt;&gt;&gt; aid_list = ibs.get_valid_aids(species=ZEB_PLAIN)[0:3]</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Should fallback</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_augmented_ibeis_nnindexer(qreq_, aid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # assert the fallback</span>\n<span class=\"sd\">        &gt;&gt;&gt; uncovered_aids, covered_aids_list = group_daids_by_cached_nnindexer(</span>\n<span class=\"sd\">        ...     qreq_, daid_list, min_reindex_thresh, max_covers)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result2 = uncovered_aids, covered_aids_list</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.assert_eq(result2, ([4, 5, 6], [[1, 2, 3]]), &#39;pre augment&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Should augment</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_augmented_ibeis_nnindexer(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; uncovered_aids, covered_aids_list = group_daids_by_cached_nnindexer(</span>\n<span class=\"sd\">        ...     qreq_, daid_list, min_reindex_thresh, max_covers)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result3 = uncovered_aids, covered_aids_list</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.assert_eq(result3, ([], [[1, 2, 3, 4, 5, 6]]), &#39;post augment&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Should fallback</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer2 = request_augmented_ibeis_nnindexer(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; assert nnindexer is nnindexer2</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">global</span> <span class=\"n\">NEIGHBOR_CACHE</span>\n    <span class=\"n\">min_reindex_thresh</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">min_reindex_thresh</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">force_rebuild</span><span class=\"p\">:</span>\n        <span class=\"n\">new_daid_list</span><span class=\"p\">,</span> <span class=\"n\">covered_aids_list</span> <span class=\"o\">=</span> <span class=\"n\">group_daids_by_cached_nnindexer</span><span class=\"p\">(</span>\n            <span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">,</span> <span class=\"n\">max_covers</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">can_augment</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n            <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">covered_aids_list</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span>\n            <span class=\"ow\">not</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">list_set_equal</span><span class=\"p\">(</span><span class=\"n\">covered_aids_list</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">daid_list</span><span class=\"p\">))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">can_augment</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[aug] Requesting augmented nnindexer&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">can_augment</span><span class=\"p\">:</span>\n        <span class=\"n\">covered_aids</span> <span class=\"o\">=</span> <span class=\"n\">covered_aids_list</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[aug] Augmenting index </span><span class=\"si\">%r</span><span class=\"s1\"> old daids with </span><span class=\"si\">%d</span><span class=\"s1\"> new daids&#39;</span> <span class=\"o\">%</span>\n                  <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">covered_aids</span><span class=\"p\">),</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">new_daid_list</span><span class=\"p\">)))</span>\n        <span class=\"c1\"># Load the base covered indexer</span>\n        <span class=\"c1\"># THIS SHOULD LOAD NOT REBUILD IF THE UUIDS ARE COVERED</span>\n        <span class=\"n\">base_nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_memcached_ibeis_nnindexer</span><span class=\"p\">(</span>\n            <span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">covered_aids</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">,</span> <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"n\">use_memcache</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Remove this indexer from the memcache because we are going to change it</span>\n        <span class=\"k\">if</span> <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"o\">.</span><span class=\"n\">has_key</span><span class=\"p\">(</span><span class=\"n\">base_nnindexer</span><span class=\"o\">.</span><span class=\"n\">cfgstr</span><span class=\"p\">):</span>  <span class=\"c1\"># NOQA</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Removing key from memcache&#39;</span><span class=\"p\">)</span>\n            <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">[</span><span class=\"n\">base_nnindexer</span><span class=\"o\">.</span><span class=\"n\">cfgstr</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n            <span class=\"k\">del</span> <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">[</span><span class=\"n\">base_nnindexer</span><span class=\"o\">.</span><span class=\"n\">cfgstr</span><span class=\"p\">]</span>\n\n        <span class=\"n\">support_data</span> <span class=\"o\">=</span> <span class=\"n\">get_support_data</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">new_daid_list</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"n\">new_vecs_list</span><span class=\"p\">,</span> <span class=\"n\">new_fgws_list</span><span class=\"p\">,</span> <span class=\"n\">new_fxs_list</span><span class=\"p\">)</span>  <span class=\"o\">=</span> <span class=\"n\">support_data</span>\n        <span class=\"n\">base_nnindexer</span><span class=\"o\">.</span><span class=\"n\">add_support</span><span class=\"p\">(</span><span class=\"n\">new_daid_list</span><span class=\"p\">,</span> <span class=\"n\">new_vecs_list</span><span class=\"p\">,</span> <span class=\"n\">new_fgws_list</span><span class=\"p\">,</span>\n                                   <span class=\"n\">new_fxs_list</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"c1\"># FIXME: pointer issues</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">base_nnindexer</span>\n        <span class=\"c1\"># Change to the new cfgstr</span>\n        <span class=\"n\">nnindex_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">build_nnindex_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n        <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">nnindex_cfgstr</span>\n        <span class=\"n\">cachedir</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_flann_cachedir</span><span class=\"p\">()</span>\n        <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Write to inverse uuid</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">:</span>\n            <span class=\"n\">uuid_map_fpath</span> <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n            <span class=\"n\">daids_hashid</span>   <span class=\"o\">=</span> <span class=\"n\">get_data_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n            <span class=\"n\">visual_uuid_list</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_visual_uuids</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>\n            <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">write_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span>\n                                               <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Write to memcache</span>\n        <span class=\"k\">if</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[aug] Wrote to memcache=</span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,))</span>\n        <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">[</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nnindexer</span>\n        <span class=\"k\">return</span> <span class=\"n\">nnindexer</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\">#if ut.VERBOSE:</span>\n        <span class=\"k\">if</span> <span class=\"n\">verbose</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[aug] Nothing to augment, fallback to memcache&#39;</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Fallback</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_memcached_ibeis_nnindexer</span><span class=\"p\">(</span>\n            <span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">,</span> <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"n\">use_memcache</span><span class=\"p\">,</span>\n            <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"n\">force_rebuild</span><span class=\"p\">,</span> <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"n\">memtrack</span>\n        <span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">nnindexer</span></div>\n\n\n<div class=\"viewcode-block\" id=\"request_memcached_ibeis_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.request_memcached_ibeis_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">request_memcached_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                                      <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">NOT_QUIET</span><span class=\"p\">,</span> <span class=\"n\">veryverbose</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n                                      <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n                                      <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    FOR INTERNAL USE ONLY</span>\n<span class=\"sd\">    takes custom daid list. might not be the same as what is in qreq_</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-request_memcached_ibeis_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; # build test data</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_.qparams.min_reindex_thresh = 3</span>\n<span class=\"sd\">        &gt;&gt;&gt; ZEB_PLAIN = ibeis.const.TEST_SPECIES.ZEB_PLAIN</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ZEB_PLAIN)[0:3]</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; verbose = True</span>\n<span class=\"sd\">        &gt;&gt;&gt; use_memcache = True</span>\n<span class=\"sd\">        &gt;&gt;&gt; # execute function</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_memcached_ibeis_nnindexer(qreq_, daid_list, use_memcache)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # verify results</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(nnindexer)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">global</span> <span class=\"n\">NEIGHBOR_CACHE</span>\n    <span class=\"c1\">#try:</span>\n    <span class=\"k\">if</span> <span class=\"n\">veryverbose</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex.MEMCACHE] len(NEIGHBOR_CACHE) = </span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">),))</span>\n        <span class=\"c1\"># the lru cache wont be recognized by get_object_size_str, cast to pure python objects</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex.MEMCACHE] size(NEIGHBOR_CACHE) = </span><span class=\"si\">%s</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">get_object_size_str</span><span class=\"p\">(</span><span class=\"n\">NEIGHBOR_CACHE</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()),))</span>\n    <span class=\"c1\">#if memtrack is not None:</span>\n    <span class=\"c1\">#    memtrack.report(&#39;IN REQUEST MEMCACHE&#39;)</span>\n    <span class=\"n\">nnindex_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">build_nnindex_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"c1\"># neighbor memory cache</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">force_rebuild</span> <span class=\"ow\">and</span> <span class=\"n\">use_memcache</span> <span class=\"ow\">and</span> <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"o\">.</span><span class=\"n\">has_key</span><span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">):</span>  <span class=\"c1\"># NOQA (has_key is for a lru cache)</span>\n        <span class=\"k\">if</span> <span class=\"n\">veryverbose</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERYVERBOSE</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;... nnindex memcache hit: cfgstr=</span><span class=\"si\">%s</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,))</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">[</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">veryverbose</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERYVERBOSE</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;... nnindex memcache miss: cfgstr=</span><span class=\"si\">%s</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,))</span>\n        <span class=\"c1\"># Write to inverse uuid</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_diskcached_ibeis_nnindexer</span><span class=\"p\">(</span>\n            <span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"p\">,</span>\n            <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"n\">force_rebuild</span><span class=\"p\">,</span> <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"n\">memtrack</span><span class=\"p\">,</span>\n            <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"n\">prog_hook</span><span class=\"p\">)</span>\n        <span class=\"n\">NEIGHBOR_CACHE_WRITE</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"k\">if</span> <span class=\"n\">NEIGHBOR_CACHE_WRITE</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Write to memcache</span>\n            <span class=\"k\">if</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERYVERBOSE</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[disk] Write to memcache=</span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,))</span>\n            <span class=\"n\">NEIGHBOR_CACHE</span><span class=\"p\">[</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nnindexer</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERBOSE</span> <span class=\"ow\">or</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">VERYVERBOSE</span><span class=\"p\">:</span>\n                <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[disk] Did not write to memcache=</span><span class=\"si\">%r</span><span class=\"s1\">&#39;</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">nnindex_cfgstr</span><span class=\"p\">,))</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindexer</span></div>\n\n\n<div class=\"viewcode-block\" id=\"request_diskcached_ibeis_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.request_diskcached_ibeis_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">request_diskcached_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">nnindex_cfgstr</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n                                       <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n                                       <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    builds new NeighborIndexer which will try to use a disk cached flann if</span>\n<span class=\"sd\">    available</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        qreq_ (QueryRequest):  query request object with hyper-parameters</span>\n<span class=\"sd\">        daid_list (list):</span>\n<span class=\"sd\">        nnindex_cfgstr (?):</span>\n<span class=\"sd\">        verbose (bool):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        NeighborIndexer: nnindexer</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-request_diskcached_ibeis_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; # build test data</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ibeis.const.TEST_SPECIES.ZEB_PLAIN)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindex_cfgstr = build_nnindex_cfgstr(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; verbose = True</span>\n<span class=\"sd\">        &gt;&gt;&gt; # execute function</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_diskcached_ibeis_nnindexer(qreq_, daid_list, nnindex_cfgstr, verbose)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # verify results</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(nnindexer)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">nnindex_cfgstr</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">nnindex_cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">build_nnindex_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">nnindex_cfgstr</span>\n    <span class=\"n\">cachedir</span>     <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_flann_cachedir</span><span class=\"p\">()</span>\n    <span class=\"n\">flann_params</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">flann_params</span>\n    <span class=\"n\">flann_params</span><span class=\"p\">[</span><span class=\"s1\">&#39;checks&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">checks</span>\n    <span class=\"c1\">#if memtrack is not None:</span>\n    <span class=\"c1\">#    memtrack.report(&#39;[PRE SUPPORT]&#39;)</span>\n    <span class=\"c1\"># Get annot descriptors to index</span>\n    <span class=\"k\">if</span> <span class=\"n\">prog_hook</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">prog_hook</span><span class=\"o\">.</span><span class=\"n\">set_progress</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Loading support data for indexer&#39;</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[nnindex] Loading support data for indexer&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span> <span class=\"o\">=</span> <span class=\"n\">get_support_data</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">memtrack</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">memtrack</span><span class=\"o\">.</span><span class=\"n\">report</span><span class=\"p\">(</span><span class=\"s1\">&#39;[AFTER GET SUPPORT DATA]&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">new_neighbor_index</span><span class=\"p\">(</span>\n            <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span> <span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cachedir</span><span class=\"p\">,</span>\n            <span class=\"n\">cfgstr</span><span class=\"o\">=</span><span class=\"n\">cfgstr</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">,</span> <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"n\">force_rebuild</span><span class=\"p\">,</span>\n            <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"n\">memtrack</span><span class=\"p\">,</span> <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"n\">prog_hook</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"ne\">Exception</span> <span class=\"k\">as</span> <span class=\"n\">ex</span><span class=\"p\">:</span>\n        <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">printex</span><span class=\"p\">(</span><span class=\"n\">ex</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">msg_</span><span class=\"o\">=</span><span class=\"s1\">&#39;cannot build inverted index&#39;</span><span class=\"p\">,</span>\n                        <span class=\"n\">key_list</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;ibs.get_infostr()&#39;</span><span class=\"p\">])</span>\n        <span class=\"k\">raise</span>\n    <span class=\"c1\"># Record these uuids in the disk based uuid map so they can be augmented if</span>\n    <span class=\"c1\"># needed</span>\n    <span class=\"n\">min_reindex_thresh</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">min_reindex_thresh</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">:</span>\n        <span class=\"n\">uuid_map_fpath</span> <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n        <span class=\"n\">daids_hashid</span>   <span class=\"o\">=</span> <span class=\"n\">get_data_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n        <span class=\"n\">visual_uuid_list</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_visual_uuids</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>\n        <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">write_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">memtrack</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">memtrack</span><span class=\"o\">.</span><span class=\"n\">report</span><span class=\"p\">(</span><span class=\"s1\">&#39;[AFTER WRITE_UUID_MAP]&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindexer</span></div>\n\n\n<div class=\"viewcode-block\" id=\"group_daids_by_cached_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.group_daids_by_cached_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">group_daids_by_cached_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">,</span>\n                                    <span class=\"n\">max_covers</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-group_daids_by_cached_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ZEB_PLAIN = ibeis.const.TEST_SPECIES.ZEB_PLAIN</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ZEB_PLAIN)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Set the params a bit lower</span>\n<span class=\"sd\">        &gt;&gt;&gt; max_covers = None</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_.qparams.min_reindex_thresh = 1</span>\n<span class=\"sd\">        &gt;&gt;&gt; min_reindex_thresh = qreq_.qparams.min_reindex_thresh</span>\n<span class=\"sd\">        &gt;&gt;&gt; # STEP 0: CLEAR THE CACHE</span>\n<span class=\"sd\">        &gt;&gt;&gt; clear_uuid_cache(qreq_)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # STEP 1: ASSERT EMPTY INDEX</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ZEB_PLAIN)[0:3]</span>\n<span class=\"sd\">        &gt;&gt;&gt; uncovered_aids, covered_aids_list = group_daids_by_cached_nnindexer(</span>\n<span class=\"sd\">        ...     qreq_, daid_list, min_reindex_thresh, max_covers)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result1 = uncovered_aids, covered_aids_list</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.assert_eq(result1, ([1, 2, 3], []), &#39;pre request&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # TEST 2: SHOULD MAKE 123 COVERED</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = request_memcached_ibeis_nnindexer(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; uncovered_aids, covered_aids_list = group_daids_by_cached_nnindexer(</span>\n<span class=\"sd\">        ...     qreq_, daid_list, min_reindex_thresh, max_covers)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result2 = uncovered_aids, covered_aids_list</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.assert_eq(result2, ([], [[1, 2, 3]]), &#39;post request&#39;)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">ibs</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span>\n    <span class=\"c1\"># read which annotations have prebuilt caches</span>\n    <span class=\"n\">uuid_map_fpath</span> <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n    <span class=\"n\">candidate_uuids</span> <span class=\"o\">=</span> <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">read_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">)</span>\n    <span class=\"c1\"># find a maximum independent set cover of the requested annotations</span>\n    <span class=\"n\">annot_vuuid_list</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_visual_uuids</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>  <span class=\"c1\"># 3.2 %</span>\n    <span class=\"n\">covertup</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">greedy_max_inden_setcover</span><span class=\"p\">(</span>\n        <span class=\"n\">candidate_uuids</span><span class=\"p\">,</span> <span class=\"n\">annot_vuuid_list</span><span class=\"p\">,</span> <span class=\"n\">max_covers</span><span class=\"p\">)</span>  <span class=\"c1\"># 0.2 %</span>\n    <span class=\"n\">uncovered_vuuids</span><span class=\"p\">,</span> <span class=\"n\">covered_vuuids_list</span><span class=\"p\">,</span> <span class=\"n\">accepted_keys</span> <span class=\"o\">=</span> <span class=\"n\">covertup</span>\n    <span class=\"c1\"># return the grouped covered items (so they can be loaded) and</span>\n    <span class=\"c1\"># the remaining uuids which need to have an index computed.</span>\n    <span class=\"c1\">#</span>\n    <span class=\"n\">uncovered_aids_</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_aids_from_visual_uuid</span><span class=\"p\">(</span><span class=\"n\">uncovered_vuuids</span><span class=\"p\">)</span>  <span class=\"c1\"># 28.0%</span>\n    <span class=\"n\">covered_aids_list_</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">unflat_map</span><span class=\"p\">(</span>\n        <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_aids_from_visual_uuid</span><span class=\"p\">,</span> <span class=\"n\">covered_vuuids_list</span><span class=\"p\">)</span>  <span class=\"c1\"># 68%</span>\n    <span class=\"c1\"># FIXME:</span>\n    <span class=\"n\">uncovered_aids</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">uncovered_aids_</span><span class=\"p\">)</span>\n    <span class=\"c1\">#covered_aids_list = list(map(sorted, covered_aids_list_))</span>\n    <span class=\"n\">covered_aids_list</span> <span class=\"o\">=</span> <span class=\"n\">covered_aids_list_</span>\n    <span class=\"k\">return</span> <span class=\"n\">uncovered_aids</span><span class=\"p\">,</span> <span class=\"n\">covered_aids_list</span></div>\n\n\n<div class=\"viewcode-block\" id=\"get_data_cfgstr\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.get_data_cfgstr\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">get_data_cfgstr</span><span class=\"p\">(</span><span class=\"n\">ibs</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot; part 2 data hash id &quot;&quot;&quot;</span>\n    <span class=\"n\">daids_hashid</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_hashid_visual_uuid</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">daids_hashid</span></div>\n\n\n<div class=\"viewcode-block\" id=\"new_neighbor_index\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.new_neighbor_index\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">new_neighbor_index</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span> <span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cachedir</span><span class=\"p\">,</span>\n                       <span class=\"n\">cfgstr</span><span class=\"p\">,</span> <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                       <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    constructs neighbor index independent of ibeis</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        daid_list (list):</span>\n<span class=\"sd\">        vecs_list (list):</span>\n<span class=\"sd\">        fgws_list (list):</span>\n<span class=\"sd\">        flann_params (dict):</span>\n<span class=\"sd\">        flann_cachedir (None):</span>\n<span class=\"sd\">        nnindex_cfgstr (str):</span>\n<span class=\"sd\">        use_memcache (bool):</span>\n\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        nnindexer</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-new_neighbor_index</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibeis.testdata_qreq_(defaultdb=&#39;testdb1&#39;, a=&#39;default:species=zebra_plains&#39;, p=&#39;default:fgw_thresh=.999&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = qreq_.daids</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindex_cfgstr = build_nnindex_cfgstr(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; ut.exec_funckw(new_neighbor_index, globals())</span>\n<span class=\"sd\">        &gt;&gt;&gt; cfgstr = nnindex_cfgstr</span>\n<span class=\"sd\">        &gt;&gt;&gt; cachedir     = qreq_.ibs.get_flann_cachedir()</span>\n<span class=\"sd\">        &gt;&gt;&gt; flann_params = qreq_.qparams.flann_params</span>\n<span class=\"sd\">        &gt;&gt;&gt; # Get annot descriptors to index</span>\n<span class=\"sd\">        &gt;&gt;&gt; vecs_list, fgws_list, fxs_list = get_support_data(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer = new_neighbor_index(daid_list, vecs_list, fgws_list, fxs_list, flann_params, cachedir, cfgstr, verbose=True)</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = (&#39;nnindexer.ax2_aid = %s&#39; % (str(nnindexer.ax2_aid),))</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">        nnindexer.ax2_aid = [1 2 3 4 5 6]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">NeighborIndex</span><span class=\"p\">(</span><span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cfgstr</span><span class=\"p\">)</span>\n    <span class=\"c1\">#if memtrack is not None:</span>\n    <span class=\"c1\">#    memtrack.report(&#39;CREATEED NEIGHTOB INDEX&#39;)</span>\n    <span class=\"c1\"># Initialize neighbor with unindexed data</span>\n    <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">init_support</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">memtrack</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">memtrack</span><span class=\"o\">.</span><span class=\"n\">report</span><span class=\"p\">(</span><span class=\"s1\">&#39;AFTER INIT SUPPORT&#39;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Load or build the indexing structure</span>\n    <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">ensure_indexer</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"n\">verbose</span><span class=\"p\">,</span>\n                             <span class=\"n\">force_rebuild</span><span class=\"o\">=</span><span class=\"n\">force_rebuild</span><span class=\"p\">,</span> <span class=\"n\">memtrack</span><span class=\"o\">=</span><span class=\"n\">memtrack</span><span class=\"p\">,</span>\n                             <span class=\"n\">prog_hook</span><span class=\"o\">=</span><span class=\"n\">prog_hook</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">memtrack</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">memtrack</span><span class=\"o\">.</span><span class=\"n\">report</span><span class=\"p\">(</span><span class=\"s1\">&#39;AFTER LOAD OR BUILD&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindexer</span></div>\n\n\n<div class=\"viewcode-block\" id=\"testdata_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.testdata_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">testdata_nnindexer</span><span class=\"p\">(</span><span class=\"n\">dbname</span><span class=\"o\">=</span><span class=\"s1\">&#39;testdb1&#39;</span><span class=\"p\">,</span> <span class=\"n\">with_indexer</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n\n<span class=\"sd\">    Ignore:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer, qreq_, ibs = testdata_nnindexer(&#39;PZ_Master1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; S = np.cov(nnindexer.idx2_vec.T)</span>\n<span class=\"sd\">        &gt;&gt;&gt; import plottool as pt</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.ensureqt()</span>\n<span class=\"sd\">        &gt;&gt;&gt; pt.plt.imshow(S)</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; nnindexer, qreq_, ibs = testdata_nnindexer()</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">ibeis</span>\n    <span class=\"n\">daid_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">]</span>\n    <span class=\"n\">ibs</span> <span class=\"o\">=</span> <span class=\"n\">ibeis</span><span class=\"o\">.</span><span class=\"n\">opendb</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">=</span><span class=\"n\">dbname</span><span class=\"p\">)</span>\n    <span class=\"c1\"># use_memcache isn&#39;t use here because we aren&#39;t lazy loading the indexer</span>\n    <span class=\"n\">cfgdict</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">fg_on</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n    <span class=\"n\">qreq_</span> <span class=\"o\">=</span> <span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">new_query_request</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span>\n                                  <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"n\">use_memcache</span><span class=\"p\">,</span> <span class=\"n\">cfgdict</span><span class=\"o\">=</span><span class=\"n\">cfgdict</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">with_indexer</span><span class=\"p\">:</span>\n        <span class=\"c1\"># we do an explicit creation of an indexer for these tests</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">request_ibeis_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">use_memcache</span><span class=\"o\">=</span><span class=\"n\">use_memcache</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n    <span class=\"k\">return</span> <span class=\"n\">nnindexer</span><span class=\"p\">,</span> <span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">ibs</span></div>\n\n\n<span class=\"c1\"># ------------</span>\n<span class=\"c1\"># NEW</span>\n\n\n<div class=\"viewcode-block\" id=\"check_background_process\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.check_background_process\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">check_background_process</span><span class=\"p\">():</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    checks to see if the process has finished and then</span>\n<span class=\"sd\">    writes the uuid map to disk</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">global</span> <span class=\"n\">CURRENT_THREAD</span>\n    <span class=\"k\">if</span> <span class=\"n\">CURRENT_THREAD</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">or</span> <span class=\"n\">CURRENT_THREAD</span><span class=\"o\">.</span><span class=\"n\">is_alive</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[FG] background thread is not ready yet&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n    <span class=\"c1\"># Get info set in background process</span>\n    <span class=\"n\">finishtup</span> <span class=\"o\">=</span> <span class=\"n\">CURRENT_THREAD</span><span class=\"o\">.</span><span class=\"n\">finishtup</span>\n    <span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">finishtup</span>\n    <span class=\"c1\"># Clean up background process</span>\n    <span class=\"n\">CURRENT_THREAD</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n    <span class=\"n\">CURRENT_THREAD</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n    <span class=\"c1\"># Write data to current uuidcache</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">visual_uuid_list</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">:</span>\n        <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">write_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"kc\">True</span></div>\n\n\n<div class=\"viewcode-block\" id=\"can_request_background_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.can_request_background_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">can_request_background_nnindexer</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">CURRENT_THREAD</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">or</span> <span class=\"ow\">not</span> <span class=\"n\">CURRENT_THREAD</span><span class=\"o\">.</span><span class=\"n\">is_alive</span><span class=\"p\">()</span></div>\n\n\n<div class=\"viewcode-block\" id=\"request_background_nnindexer\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.request_background_nnindexer\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">request_background_nnindexer</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot; FIXME: Duplicate code</span>\n\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        qreq_ (QueryRequest):  query request object with hyper-parameters</span>\n<span class=\"sd\">        daid_list (list):</span>\n\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --test-request_background_nnindexer</span>\n\n<span class=\"sd\">    Example:</span>\n<span class=\"sd\">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>\n<span class=\"sd\">        &gt;&gt;&gt; from ibeis.algo.hots.neighbor_index_cache import *  # NOQA</span>\n<span class=\"sd\">        &gt;&gt;&gt; import ibeis</span>\n<span class=\"sd\">        &gt;&gt;&gt; # build test data</span>\n<span class=\"sd\">        &gt;&gt;&gt; ibs = ibeis.opendb(&#39;testdb1&#39;)</span>\n<span class=\"sd\">        &gt;&gt;&gt; daid_list = ibs.get_valid_aids(species=ibeis.const.TEST_SPECIES.ZEB_PLAIN)</span>\n<span class=\"sd\">        &gt;&gt;&gt; qreq_ = ibs.new_query_request(daid_list, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # execute function</span>\n<span class=\"sd\">        &gt;&gt;&gt; request_background_nnindexer(qreq_, daid_list)</span>\n<span class=\"sd\">        &gt;&gt;&gt; # verify results</span>\n<span class=\"sd\">        &gt;&gt;&gt; result = str(False)</span>\n<span class=\"sd\">        &gt;&gt;&gt; print(result)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">global</span> <span class=\"n\">CURRENT_THREAD</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;Requesting background reindex&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">can_request_background_nnindexer</span><span class=\"p\">():</span>\n        <span class=\"c1\"># Make sure this function doesn&#39;t run if it is already running</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;REQUEST DENIED&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;REQUEST ACCPETED&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">daids_hashid</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_hashid_visual_uuid</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">cfgstr</span> <span class=\"o\">=</span> <span class=\"n\">build_nnindex_cfgstr</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"n\">cachedir</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_flann_cachedir</span><span class=\"p\">()</span>\n    <span class=\"c1\"># Save inverted cache uuid mappings for</span>\n    <span class=\"n\">min_reindex_thresh</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">min_reindex_thresh</span>\n    <span class=\"c1\"># Grab the keypoints names and image ids before query time?</span>\n    <span class=\"n\">flann_params</span> <span class=\"o\">=</span>  <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">qparams</span><span class=\"o\">.</span><span class=\"n\">flann_params</span>\n    <span class=\"c1\"># Get annot descriptors to index</span>\n    <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span> <span class=\"o\">=</span> <span class=\"n\">get_support_data</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Dont hash rowids when given enough info in nnindex_cfgstr</span>\n    <span class=\"n\">flann_params</span><span class=\"p\">[</span><span class=\"s1\">&#39;cores&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>  <span class=\"c1\"># Only ues a few cores in the background</span>\n    <span class=\"c1\"># Build/Load the flann index</span>\n    <span class=\"n\">uuid_map_fpath</span>   <span class=\"o\">=</span> <span class=\"n\">get_nnindexer_uuid_map_fpath</span><span class=\"p\">(</span><span class=\"n\">qreq_</span><span class=\"p\">)</span>\n    <span class=\"n\">visual_uuid_list</span> <span class=\"o\">=</span> <span class=\"n\">qreq_</span><span class=\"o\">.</span><span class=\"n\">ibs</span><span class=\"o\">.</span><span class=\"n\">get_annot_visual_uuids</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># set temporary attribute for when the thread finishes</span>\n    <span class=\"n\">finishtup</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">)</span>\n    <span class=\"n\">CURRENT_THREAD</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">spawn_background_process</span><span class=\"p\">(</span>\n        <span class=\"n\">background_flann_func</span><span class=\"p\">,</span> <span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span>\n        <span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cfgstr</span><span class=\"p\">)</span>\n\n    <span class=\"n\">CURRENT_THREAD</span><span class=\"o\">.</span><span class=\"n\">finishtup</span> <span class=\"o\">=</span> <span class=\"n\">finishtup</span></div>\n\n\n<div class=\"viewcode-block\" id=\"background_flann_func\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.hots/#ibeis.algo.hots.neighbor_index_cache.background_flann_func\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">background_flann_func</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span> <span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cfgstr</span><span class=\"p\">,</span>\n                          <span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">,</span>\n                          <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">):</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot; FIXME: Duplicate code &quot;&quot;&quot;</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[BG] Starting Background FLANN&#39;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># FIXME. dont use flann cache</span>\n    <span class=\"n\">nnindexer</span> <span class=\"o\">=</span> <span class=\"n\">NeighborIndex</span><span class=\"p\">(</span><span class=\"n\">flann_params</span><span class=\"p\">,</span> <span class=\"n\">cfgstr</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Initialize neighbor with unindexed data</span>\n    <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">init_support</span><span class=\"p\">(</span><span class=\"n\">daid_list</span><span class=\"p\">,</span> <span class=\"n\">vecs_list</span><span class=\"p\">,</span> <span class=\"n\">fgws_list</span><span class=\"p\">,</span> <span class=\"n\">fxs_list</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Load or build the indexing structure</span>\n    <span class=\"n\">nnindexer</span><span class=\"o\">.</span><span class=\"n\">ensure_indexer</span><span class=\"p\">(</span><span class=\"n\">cachedir</span><span class=\"p\">,</span> <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">visual_uuid_list</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">min_reindex_thresh</span><span class=\"p\">:</span>\n        <span class=\"n\">UUID_MAP_CACHE</span><span class=\"o\">.</span><span class=\"n\">write_uuid_map_dict</span><span class=\"p\">(</span><span class=\"n\">uuid_map_fpath</span><span class=\"p\">,</span> <span class=\"n\">visual_uuid_list</span><span class=\"p\">,</span> <span class=\"n\">daids_hashid</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;[BG] Finished Background FLANN&#39;</span><span class=\"p\">)</span></div>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"sa\">r</span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    CommandLine:</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache</span>\n<span class=\"sd\">        python -m ibeis.algo.hots.neighbor_index_cache --allexamples</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">multiprocessing</span>\n    <span class=\"n\">multiprocessing</span><span class=\"o\">.</span><span class=\"n\">freeze_support</span><span class=\"p\">()</span>  <span class=\"c1\"># for win32</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>  <span class=\"c1\"># NOQA</span>\n    <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">doctest_funcs</span><span class=\"p\">()</span>\n</pre></div>", "current_page_name": "_modules/ibeis/algo/hots/neighbor_index_cache", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}