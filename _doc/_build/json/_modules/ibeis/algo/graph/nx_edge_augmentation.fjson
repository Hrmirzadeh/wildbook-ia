{"parents": [{"link": "../../../../", "title": "Module code"}, {"link": "../../../", "title": "ibeis"}, {"link": "../../", "title": "ibeis.algo"}, {"link": "../", "title": "ibeis.algo.graph"}], "title": "ibeis.algo.graph.nx_edge_augmentation", "body": "<h1>Source code for ibeis.algo.graph.nx_edge_augmentation</h1><div class=\"highlight\"><pre>\n<span></span><span class=\"c1\"># -*- coding: utf-8 -*-</span>\n<span class=\"c1\">#    Copyright (C) 2004-2017 by</span>\n<span class=\"c1\">#    Aric Hagberg &lt;hagberg@lanl.gov&gt;</span>\n<span class=\"c1\">#    Dan Schult &lt;dschult@colgate.edu&gt;</span>\n<span class=\"c1\">#    Pieter Swart &lt;swart@lanl.gov&gt;</span>\n<span class=\"c1\">#    All rights reserved.</span>\n<span class=\"c1\">#    BSD license.</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Authors: Jon Crall (erotemic@gmail.com)</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">Algorithms for finding k-edge-augmentations</span>\n\n<span class=\"sd\">A k-edge-augmentation is a set of edges, that once added to a graph, ensures</span>\n<span class=\"sd\">that the graph is k-edge-connected. Typically, the goal is to find the</span>\n<span class=\"sd\">augmentation with minimum weight. In general, it is not gaurenteed that a</span>\n<span class=\"sd\">k-edge-augmentation exists.</span>\n<span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"k\">import</span> <span class=\"n\">absolute_import</span><span class=\"p\">,</span> <span class=\"n\">division</span><span class=\"p\">,</span> <span class=\"n\">print_function</span><span class=\"p\">,</span> <span class=\"n\">unicode_literals</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"kn\">import</span> <span class=\"nn\">math</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">itertools</span> <span class=\"k\">as</span> <span class=\"nn\">it</span>\n<span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"nn\">nx</span>\n<span class=\"kn\">from</span> <span class=\"nn\">networkx.utils</span> <span class=\"k\">import</span> <span class=\"n\">not_implemented_for</span>\n<span class=\"kn\">from</span> <span class=\"nn\">collections</span> <span class=\"k\">import</span> <span class=\"n\">defaultdict</span><span class=\"p\">,</span> <span class=\"n\">namedtuple</span>\n\n<span class=\"c1\"># Patch</span>\n<span class=\"kn\">from</span> <span class=\"nn\">ibeis.algo.graph</span> <span class=\"k\">import</span> <span class=\"n\">nx_edge_kcomponents</span> <span class=\"k\">as</span> <span class=\"n\">nx_ec</span>  <span class=\"c1\"># NOQA</span>\n<span class=\"kn\">import</span> <span class=\"nn\">utool</span> <span class=\"k\">as</span> <span class=\"nn\">ut</span>\n<span class=\"nb\">print</span><span class=\"p\">,</span> <span class=\"n\">rrr</span><span class=\"p\">,</span> <span class=\"n\">profile</span> <span class=\"o\">=</span> <span class=\"n\">ut</span><span class=\"o\">.</span><span class=\"n\">inject2</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># __all__ = [</span>\n<span class=\"c1\">#     &#39;k_edge_augmentation&#39;,</span>\n<span class=\"c1\">#     &#39;is_k_edge_connected&#39;,</span>\n<span class=\"c1\">#     &#39;is_locally_k_edge_connected&#39;,</span>\n<span class=\"c1\"># ]</span>\n\n\n<div class=\"viewcode-block\" id=\"is_k_edge_connected\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.is_k_edge_connected\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">is_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Tests to see if a graph is k-edge-connected</span>\n\n<span class=\"sd\">    See Also</span>\n<span class=\"sd\">    --------</span>\n<span class=\"sd\">    is_locally_k_edge_connected</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.barbell_graph(10, 0)</span>\n<span class=\"sd\">    &gt;&gt;&gt; is_k_edge_connected(G, k=1)</span>\n<span class=\"sd\">    True</span>\n<span class=\"sd\">    &gt;&gt;&gt; is_k_edge_connected(G, k=2)</span>\n<span class=\"sd\">    False</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;k must be positive, not </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">))</span>\n    <span class=\"c1\"># First try to quickly determine if G is not k-edge-connected</span>\n    <span class=\"k\">if</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">number_of_nodes</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n    <span class=\"k\">elif</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">d</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">()):</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Otherwise perform the full check</span>\n        <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">is_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"ow\">not</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">has_bridges</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># return nx.edge_connectivity(G, cutoff=k) &gt;= k</span>\n            <span class=\"k\">return</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">edge_connectivity</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span></div>\n\n\n<div class=\"viewcode-block\" id=\"is_locally_k_edge_connected\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.is_locally_k_edge_connected\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">is_locally_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Tests to see if an edge in a graph is locally k-edge-connected</span>\n\n<span class=\"sd\">    See Also</span>\n<span class=\"sd\">    --------</span>\n<span class=\"sd\">    is_k_edge_connected</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.barbell_graph(10, 0)</span>\n<span class=\"sd\">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 5, 15, k=1)</span>\n<span class=\"sd\">    True</span>\n<span class=\"sd\">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 5, 15, k=2)</span>\n<span class=\"sd\">    False</span>\n<span class=\"sd\">    &gt;&gt;&gt; is_locally_k_edge_connected(G, 1, 5, k=2)</span>\n<span class=\"sd\">    True</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;k must be positive, not </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># First try to quickly determine s, t is not k-locally-edge-connected in G</span>\n    <span class=\"k\">if</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span> <span class=\"ow\">or</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Otherwise perform the full check</span>\n        <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">has_path</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">localk</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">local_edge_connectivity</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">cutoff</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">localk</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span></div>\n\n\n<div class=\"viewcode-block\" id=\"k_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.k_edge_augmentation\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">k_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">partial</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds set of edges to k-edge-connect G.</span>\n\n<span class=\"sd\">    This function uses the most efficient function available (depending on the</span>\n<span class=\"sd\">    value of k and if the problem is weighted or unweighted) to search for a</span>\n<span class=\"sd\">    minimum weight subset of available edges that k-edge-connects G.</span>\n<span class=\"sd\">    In general, finding a k-edge-augmentation is NP-hard, so solutions are not</span>\n<span class=\"sd\">    garuenteed to be minimal.</span>\n\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    G : NetworkX graph</span>\n\n<span class=\"sd\">    k : Integer</span>\n<span class=\"sd\">        Desired edge connectivity</span>\n\n<span class=\"sd\">    avail : dict or a set 2 or 3 tuples</span>\n<span class=\"sd\">        The available edges that can be used in the augmentation.</span>\n\n<span class=\"sd\">        If unspecified, then all edges in the complement of G are available.</span>\n<span class=\"sd\">        Otherwise, each item is an available edge (with an optinal weight).</span>\n\n<span class=\"sd\">        In the unweighted case, each item is an edge ``(u, v)``.</span>\n\n<span class=\"sd\">        In the weighted case, each item is a 3-tuple ``(u, v, d)`` or a dict</span>\n<span class=\"sd\">        with items ``(u, v): d``.  The third item, ``d``, can be a dictionary</span>\n<span class=\"sd\">        or a real number.  If ``d`` is a dictionary ``d[weight]``</span>\n<span class=\"sd\">        correspondings to the weight.</span>\n\n<span class=\"sd\">    weight : string</span>\n<span class=\"sd\">        key to use to find weights if avail is a set of 3-tuples where the</span>\n<span class=\"sd\">        third item in each tuple is a dictionary.</span>\n\n<span class=\"sd\">    partial : Boolean</span>\n<span class=\"sd\">        If partial is True and no feasible k-edge-augmentation exists, then all</span>\n<span class=\"sd\">        available edges are returned.</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    aug_edges : a generator of edges. If these edges are added to G, then</span>\n<span class=\"sd\">        the G would become k-edge-connected. If partial is False, an error</span>\n<span class=\"sd\">        is raised if this is not possible. Otherwise, all available edges</span>\n<span class=\"sd\">        are generated.</span>\n\n<span class=\"sd\">    Raises</span>\n<span class=\"sd\">    ------</span>\n<span class=\"sd\">    NetworkXNotImplemented:</span>\n<span class=\"sd\">        If the input graph is directed or a multigraph.</span>\n\n<span class=\"sd\">    ValueError:</span>\n<span class=\"sd\">        If k is less than 1</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    When k=1 this returns an optimal solution.</span>\n\n<span class=\"sd\">    When k=2 and avail is None, this returns an optimal solution.</span>\n<span class=\"sd\">    Otherwise when k=2, this returns a 2-approximation of the optimal solution.</span>\n\n<span class=\"sd\">    For k&gt;3, this problem is NP-hard and this uses a randomized algorithm that</span>\n<span class=\"sd\">        produces a feasible solution, but provides no gaurentees on the</span>\n<span class=\"sd\">        solution weight.</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; # Unweighted cases</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(5)</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=1))</span>\n<span class=\"sd\">    [(1, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2))</span>\n<span class=\"sd\">    [(1, 5), (5, 4)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=3))</span>\n<span class=\"sd\">    [(1, 4), (1, 5), (2, 5), (3, 5), (4, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; complement = list(k_edge_augmentation(G, k=5, partial=True))</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_edges_from(complement)</span>\n<span class=\"sd\">    &gt;&gt;&gt; nx.edge_connectivity(G)</span>\n<span class=\"sd\">    4</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; # Weighted cases</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(5)</span>\n<span class=\"sd\">    &gt;&gt;&gt; # avail can be a tuple with a dict</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 5, {&#39;weight&#39;: 11}), (2, 5, {&#39;weight&#39;: 10})]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=1, avail=avail, weight=&#39;weight&#39;))</span>\n<span class=\"sd\">    [(2, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; # or avail can be a 3-tuple with a real number</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail))</span>\n<span class=\"sd\">    [(1, 5), (2, 5), (4, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; # or avail can be a dict</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = {(1, 5): 11, (2, 5): 10, (4, 3): 1, (4, 5): 51}</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail))</span>\n<span class=\"sd\">    [(1, 5), (2, 5), (4, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; # If augmentation is infeasible, then all edges in avail are returned</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = {(1, 5): 11}</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(k_edge_augmentation(G, k=2, avail=avail, partial=True))</span>\n<span class=\"sd\">    [(1, 5)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;k must be a positive integer, not </span><span class=\"si\">{}</span><span class=\"s1\">&#39;</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">))</span>\n        <span class=\"k\">elif</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">number_of_nodes</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span>\n                <span class=\"p\">(</span><span class=\"s1\">&#39;impossible to </span><span class=\"si\">{}</span><span class=\"s1\"> connect in graph with less than </span><span class=\"si\">{}</span><span class=\"s1\"> &#39;</span>\n                 <span class=\"s1\">&#39;nodes&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n        <span class=\"k\">elif</span> <span class=\"n\">avail</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">is_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span><span class=\"s1\">&#39;no available edges&#39;</span><span class=\"p\">)</span>\n            <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">elif</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"n\">one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span>\n                                              <span class=\"n\">partial</span><span class=\"o\">=</span><span class=\"n\">partial</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">k</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n            <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"n\">bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># raise NotImplementedError(</span>\n            <span class=\"c1\">#    &#39;not implemented for k&gt;2. k={}&#39;.format(k))</span>\n            <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"n\">greedy_k_edge_augmentation</span><span class=\"p\">(</span>\n                <span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"c1\"># Do eager evaulation so we can catch any exceptions</span>\n        <span class=\"c1\"># Before executing partial code.</span>\n        <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">aug_edges</span><span class=\"p\">):</span>\n            <span class=\"k\">yield</span> <span class=\"n\">edge</span>\n    <span class=\"k\">except</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">partial</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Return all available edges</span>\n            <span class=\"k\">if</span> <span class=\"n\">avail</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"n\">complement_edges</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"c1\"># If we cant k-edge-connect the entire graph, try to</span>\n                <span class=\"c1\"># k-edge-connect as much as possible</span>\n                <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"n\">partial_k_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span>\n                                                        <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">aug_edges</span><span class=\"p\">:</span>\n                <span class=\"k\">yield</span> <span class=\"n\">edge</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span></div>\n\n\n<div class=\"viewcode-block\" id=\"partial_k_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.partial_k_edge_augmentation\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">partial_k_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds augmentation that k-edge-connects as much of the graph as possible</span>\n\n<span class=\"sd\">    When a k-edge-augmentation is not possible, we can still try to find a</span>\n<span class=\"sd\">    small set of edges that partially k-edge-connects as much of the graph as</span>\n<span class=\"sd\">    possible.</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    Construct H that augments G with all edges in avail.</span>\n<span class=\"sd\">    Find the k-edge-subgraphs of H.</span>\n<span class=\"sd\">    For each k-edge-subgraph, if the number of nodes is more than k, then find</span>\n<span class=\"sd\">    the k-edge-augmentation of that graph and add it to the solution. Then add</span>\n<span class=\"sd\">    all edges in avail between k-edge subgraphs to the solution.</span>\n\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(8)</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 3), (1, 4), (1, 5), (2, 4), (2, 5), (3, 5), (1, 8)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(partial_k_edge_augmentation(G, k=2, avail=avail))</span>\n<span class=\"sd\">    [(1, 5), (1, 8)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_edges_between_disjoint</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">only1</span><span class=\"p\">,</span> <span class=\"n\">only2</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot; finds edges between disjoint nodes &quot;&quot;&quot;</span>\n        <span class=\"n\">only1_adj</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">u</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">adj</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">u</span> <span class=\"ow\">in</span> <span class=\"n\">only1</span><span class=\"p\">}</span>\n        <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">neighbs</span> <span class=\"ow\">in</span> <span class=\"n\">only1_adj</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"c1\"># Find the neighbors of u in only1 that are also in only2</span>\n            <span class=\"n\">neighbs12</span> <span class=\"o\">=</span> <span class=\"n\">neighbs</span><span class=\"o\">.</span><span class=\"n\">intersection</span><span class=\"p\">(</span><span class=\"n\">only2</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">neighbs12</span><span class=\"p\">:</span>\n                <span class=\"k\">yield</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\n    <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"n\">_unpack_available_edges</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"o\">=</span><span class=\"n\">G</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Find which parts of the graph can be k-edge-connected</span>\n    <span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n    <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">(</span>\n        <span class=\"p\">((</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">&#39;weight&#39;</span><span class=\"p\">:</span> <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)})</span>\n         <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">),</span> <span class=\"n\">w</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span><span class=\"p\">)))</span>\n    <span class=\"n\">k_edge_subgraphs</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nx_ec</span><span class=\"o\">.</span><span class=\"n\">k_edge_subgraphs</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Generate edges to k-edge-connect internal components</span>\n    <span class=\"k\">for</span> <span class=\"n\">nodes</span> <span class=\"ow\">in</span> <span class=\"n\">k_edge_subgraphs</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">nodes</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Get the k-edge-connected subgraph</span>\n            <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">subgraph</span><span class=\"p\">(</span><span class=\"n\">nodes</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n            <span class=\"c1\"># Find the internal edges that were available</span>\n            <span class=\"n\">sub_avail</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n                <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">]:</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">&#39;weight&#39;</span><span class=\"p\">]</span>\n                <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"s1\">&#39;generator&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">d</span>\n            <span class=\"p\">}</span>\n            <span class=\"c1\"># Remove potential augmenting edges</span>\n            <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">remove_edges_from</span><span class=\"p\">(</span><span class=\"n\">sub_avail</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span>\n            <span class=\"c1\"># Find a subset of these edges that makes the compoment</span>\n            <span class=\"c1\"># k-edge-connected and ignore the rest</span>\n            <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">k_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">sub_avail</span><span class=\"p\">):</span>\n                <span class=\"k\">yield</span> <span class=\"n\">edge</span>\n\n    <span class=\"c1\"># Generate all edges between CCs that could not be k-edge-connected</span>\n    <span class=\"k\">for</span> <span class=\"n\">cc1</span><span class=\"p\">,</span> <span class=\"n\">cc2</span> <span class=\"ow\">in</span> <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">combinations</span><span class=\"p\">(</span><span class=\"n\">k_edge_subgraphs</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">_edges_between_disjoint</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">cc1</span><span class=\"p\">,</span> <span class=\"n\">cc2</span><span class=\"p\">):</span>\n            <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">get_edge_data</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n            <span class=\"n\">edge</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">edge</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"k\">yield</span> <span class=\"n\">edge</span></div>\n\n\n<div class=\"viewcode-block\" id=\"one_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.one_edge_augmentation\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">partial</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds minimum weight set of edges to connect G.</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    Uses either :func:`unconstrained_one_edge_augmentation` or</span>\n<span class=\"sd\">    :func:`weighted_one_edge_augmentation` depending on whether ``avail`` is</span>\n<span class=\"sd\">    specified. Both algorithms are based on finding a minimum spanning tree.</span>\n<span class=\"sd\">    As such both algorithms find optimal solutions and run in linear time.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">avail</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">unconstrained_one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">weighted_one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span>\n                                              <span class=\"n\">partial</span><span class=\"o\">=</span><span class=\"n\">partial</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"bridge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.bridge_augmentation\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds the a set of edges that bridge connects G.</span>\n\n<span class=\"sd\">    Adding these edges to G will make it 2-edge-connected.</span>\n<span class=\"sd\">    If no constraints are specified the returned set of edges is minimum an</span>\n<span class=\"sd\">    optimal, otherwise the solution is approximated.</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    If there are no constraints the solution can be computed in linear time</span>\n<span class=\"sd\">    using :func:`unconstrained_bridge_augmentation`. Otherwise, the problem</span>\n<span class=\"sd\">    becomes NP-hard and is the solution is approximated by</span>\n<span class=\"sd\">    :func:`weighted_bridge_augmentation`.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">number_of_nodes</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"mi\">3</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span>\n            <span class=\"s1\">&#39;impossible to bridge connect less than 3 nodes&#39;</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">avail</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">unconstrained_bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">weighted_bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">)</span></div>\n\n\n<span class=\"c1\"># --- Algorithms and Helpers ---</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">_ordered</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">u</span> <span class=\"o\">&lt;</span> <span class=\"n\">v</span> <span class=\"k\">else</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_unpack_available_edges</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Helper to separate avail into edges and corresponding weights&quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">weight</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">weight</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;weight&#39;</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">):</span>\n        <span class=\"n\">avail_uv</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span>\n        <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">def</span> <span class=\"nf\">_try_getitem</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">):</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">weight</span><span class=\"p\">]</span>\n            <span class=\"k\">except</span> <span class=\"ne\">TypeError</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">d</span>\n        <span class=\"n\">avail_uv</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">tup</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">tup</span> <span class=\"ow\">in</span> <span class=\"n\">avail</span><span class=\"p\">]</span>\n        <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">tup</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"k\">else</span> <span class=\"n\">_try_getitem</span><span class=\"p\">(</span><span class=\"n\">tup</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n                   <span class=\"k\">for</span> <span class=\"n\">tup</span> <span class=\"ow\">in</span> <span class=\"n\">avail</span><span class=\"p\">]</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">G</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Edges already in the graph are filtered</span>\n        <span class=\"c1\"># flags = [(G.has_node(u) and G.has_node(v) and not G.has_edge(u, v))</span>\n        <span class=\"c1\">#          for u, v in avail_uv]</span>\n        <span class=\"n\">flags</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"ow\">not</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">has_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">avail_uv</span><span class=\"p\">]</span>\n        <span class=\"n\">avail_uv</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">))</span>\n        <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">avail_w</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"p\">))</span>\n    <span class=\"k\">return</span> <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span>\n\n\n<span class=\"n\">MetaEdge</span> <span class=\"o\">=</span> <span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"s1\">&#39;MetaEdge&#39;</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">&#39;meta_uv&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;uv&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;w&#39;</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_lightest_meta_edges</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">,</span> <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Maps available edges in the original graph to edges in the metagraph</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    mapping : dict</span>\n<span class=\"sd\">        mapping produced by :func:`collapse`, that maps each node in the</span>\n<span class=\"sd\">        original graph to a node in the meta graph</span>\n\n<span class=\"sd\">    avail_uv : list</span>\n<span class=\"sd\">        list of edges</span>\n\n<span class=\"sd\">    avail_w : list</span>\n<span class=\"sd\">        list of edge weights</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    Each node in the metagraph is a k-edge-cc in the original graph.  We dont</span>\n<span class=\"sd\">    care about any edge within the same k-edge-cc, so we ignore self edges.  We</span>\n<span class=\"sd\">    also are only intereseted in the minimum weight edge bridging each</span>\n<span class=\"sd\">    k-edge-cc so, we group the edges by meta-edge and take the lightest in each</span>\n<span class=\"sd\">    group.</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; # Each group represents a meta-node</span>\n<span class=\"sd\">    &gt;&gt;&gt; groups = ([1, 2, 3], [4, 5], [6])</span>\n<span class=\"sd\">    &gt;&gt;&gt; mapping = {n: meta_n for meta_n, ns in enumerate(groups) for n in ns}</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail_uv = [(1, 2), (3, 6), (1, 4), (5, 2), (6, 1), (2, 6), (3, 1)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail_w =  [    20,     99,     20,     15,     50,     99,     20]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(_lightest_meta_edges(mapping, avail_uv, avail_w))</span>\n<span class=\"sd\">    [MetaEdge(meta_uv=(0, 1), uv=(5, 2), w=15), MetaEdge(meta_uv=(0, 2), uv=(6, 1), w=50)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">grouped_wuv</span> <span class=\"o\">=</span> <span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">avail_w</span><span class=\"p\">,</span> <span class=\"n\">avail_uv</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Order the meta-edge so it can be used as a dict key</span>\n        <span class=\"n\">meta_uv</span> <span class=\"o\">=</span> <span class=\"n\">_ordered</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">],</span> <span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">])</span>\n        <span class=\"c1\"># Group each available edge using the meta-edge as a key</span>\n        <span class=\"n\">grouped_wuv</span><span class=\"p\">[</span><span class=\"n\">meta_uv</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Now that all available edges are grouped, choose one per group</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"n\">choices_wuv</span> <span class=\"ow\">in</span> <span class=\"n\">grouped_wuv</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"c1\"># Ignore available edges within the same meta-node</span>\n        <span class=\"k\">if</span> <span class=\"n\">mu</span> <span class=\"o\">!=</span> <span class=\"n\">mv</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Choose the lightest available edge belonging to each meta-edge</span>\n            <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">choices_wuv</span><span class=\"p\">)</span>\n            <span class=\"k\">yield</span> <span class=\"n\">MetaEdge</span><span class=\"p\">((</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">),</span> <span class=\"n\">w</span><span class=\"p\">)</span>\n\n\n<div class=\"viewcode-block\" id=\"unconstrained_one_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.unconstrained_one_edge_augmentation\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">unconstrained_one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds the smallest set of edges to connect G.</span>\n\n<span class=\"sd\">    This is a variant of the unweighted MST problem.</span>\n<span class=\"sd\">    If G is not empty, a feasible solution always exists.</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3), (4, 5)])</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_nodes_from([6, 7, 8])</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(unconstrained_one_edge_augmentation(G))</span>\n<span class=\"sd\">    [(1, 4), (4, 6), (6, 7), (7, 8)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">ccs1</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connected_components</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">))</span>\n    <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">collapse</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">ccs1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># When we are not constrained, we can just make a meta graph tree.</span>\n    <span class=\"n\">meta_nodes</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">())</span>\n    <span class=\"c1\"># build a path in the metagraph</span>\n    <span class=\"n\">meta_aug</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">meta_nodes</span><span class=\"p\">,</span> <span class=\"n\">meta_nodes</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]))</span>\n    <span class=\"c1\"># map that path to the original graph</span>\n    <span class=\"n\">inverse</span> <span class=\"o\">=</span> <span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s1\">&#39;mapping&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span> <span class=\"ow\">in</span> <span class=\"n\">meta_aug</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"p\">(</span><span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">mu</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">mv</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span></div>\n\n\n<div class=\"viewcode-block\" id=\"weighted_one_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.weighted_one_edge_augmentation\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">weighted_one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">partial</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds the minimum weight set of edges to connect G if one exists.</span>\n\n<span class=\"sd\">    This is a variant of the weighted MST problem.</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3), (4, 5)])</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_nodes_from([6, 7, 8])</span>\n<span class=\"sd\">    &gt;&gt;&gt; # any edge not in avail has an implicit weight of infinity</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 3), (1, 5), (4, 7), (4, 8), (6, 1), (8, 1), (8, 2)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_one_edge_augmentation(G, avail))</span>\n<span class=\"sd\">    [(1, 5), (4, 7), (6, 1), (8, 1)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; # find another solution by giving large weights to edges in the</span>\n<span class=\"sd\">    &gt;&gt;&gt; # previous solution (note some of the old edges must be used)</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 3), (1, 5, 99), (4, 7, 9), (6, 1, 99), (8, 1, 99), (8, 2)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_one_edge_augmentation(G, avail))</span>\n<span class=\"sd\">    [(1, 5), (4, 7), (6, 1), (8, 2)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"n\">_unpack_available_edges</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"o\">=</span><span class=\"n\">G</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Collapse CCs in the original graph into nodes in a metagraph</span>\n    <span class=\"c1\"># Then find an MST of the metagraph instead of the original graph</span>\n    <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">collapse</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connected_components</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">))</span>\n    <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s1\">&#39;mapping&#39;</span><span class=\"p\">]</span>\n    <span class=\"c1\"># Assign each available edge to an edge in the metagraph</span>\n    <span class=\"n\">candidate_mapping</span> <span class=\"o\">=</span> <span class=\"n\">_lightest_meta_edges</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">,</span> <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span><span class=\"p\">)</span>\n    <span class=\"c1\"># nx.set_edge_attributes(C, name=&#39;weight&#39;, values=0)</span>\n    <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">(</span>\n        <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">&#39;weight&#39;</span><span class=\"p\">:</span> <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">:</span> <span class=\"n\">uv</span><span class=\"p\">})</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"n\">uv</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"ow\">in</span> <span class=\"n\">candidate_mapping</span>\n    <span class=\"p\">)</span>\n    <span class=\"c1\"># Find MST of the meta graph</span>\n    <span class=\"n\">meta_mst</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">minimum_spanning_tree</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">partial</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">is_connected</span><span class=\"p\">(</span><span class=\"n\">meta_mst</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span>\n            <span class=\"s1\">&#39;Not possible to connect G with available edges&#39;</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Yield the edge that generated the meta-edge</span>\n    <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">meta_mst</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;generator&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n            <span class=\"n\">edge</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">]</span>\n            <span class=\"k\">yield</span> <span class=\"n\">edge</span></div>\n\n\n<div class=\"viewcode-block\" id=\"unconstrained_bridge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.unconstrained_bridge_augmentation\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">unconstrained_bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds an optimal 2-edge-augmentation of G using the fewest edges.</span>\n\n<span class=\"sd\">    This is an implementation of the algorithm detailed in [1]_.</span>\n<span class=\"sd\">    The basic idea is to construct a meta-graph of bridge-ccs, connect leaf</span>\n<span class=\"sd\">    nodes of the trees to connect the entire graph, and finally connect the</span>\n<span class=\"sd\">    leafs of the tree in dfs-preorder to bridge connect the entire graph.</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    Input: a graph G.</span>\n<span class=\"sd\">    First find the bridge components of G and collapse each bridge-cc into a</span>\n<span class=\"sd\">    node of a metagraph graph C, which is gaurenteed to be a forest of trees.</span>\n\n<span class=\"sd\">    C contains p &quot;leafs&quot; --- nodes with exactly one incident edge.</span>\n<span class=\"sd\">    C contains q &quot;isolated nodes&quot; --- nodes with no incident edges.</span>\n\n<span class=\"sd\">    Theorem: If p + q &gt; 1, then at least :math:`ceil(p / 2) + q` edges are</span>\n<span class=\"sd\">        needed to bridge connect C. This algorithm achieves this min number.</span>\n\n<span class=\"sd\">    The method first adds enough edges to make G into a tree and then pairs</span>\n<span class=\"sd\">    leafs in a simple fashion.</span>\n\n<span class=\"sd\">    Let n be the number of trees in C. Let v(i) be an isolated vertex in the</span>\n<span class=\"sd\">    i-th tree if one exists, otherwise it is a pair of distinct leafs nodes</span>\n<span class=\"sd\">    in the i-th tree. Alternating edges from these sets (i.e.  adding edges</span>\n<span class=\"sd\">    A1 = [(v(i)[0], v(i + 1)[1]), v(i + 1)[0], v(i + 2)[1])...]) connects C</span>\n<span class=\"sd\">    into a tree T. This tree has p&#39; = p + 2q - 2(n -1) leafs and no isolated</span>\n<span class=\"sd\">    vertices. A1 has n - 1 edges. The next step finds ceil(p&#39; / 2) edges to</span>\n<span class=\"sd\">    biconnect any tree with p&#39; leafs.</span>\n\n<span class=\"sd\">    Convert T into an arborescence T&#39; by picking an arbitrary root node with</span>\n<span class=\"sd\">    degree &gt;= 2 and directing all edges away from the root. Note the</span>\n<span class=\"sd\">    implementation implicitly constructs T&#39;.</span>\n\n<span class=\"sd\">    The leafs of T are the nodes with no existing edges in T&#39;.</span>\n<span class=\"sd\">    Order the leafs of T&#39; by DFS prorder. Then break this list in half</span>\n<span class=\"sd\">    and add the zipped pairs to A2.</span>\n\n<span class=\"sd\">    The set A = A1 + A2 is the minimum augmentation in the metagraph.</span>\n\n<span class=\"sd\">    To convert this to edges in the original graph</span>\n\n<span class=\"sd\">    References</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    .. [1] Eswaran, Kapali P., and R. Endre Tarjan. (1975) Augmentation problems.</span>\n<span class=\"sd\">        http://epubs.siam.org/doi/abs/10.1137/0205044</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>\n<span class=\"sd\">    [(1, 7)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 2, 4, 5, 6, 7))</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>\n<span class=\"sd\">    [(1, 3), (3, 7)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.Graph([(0, 1), (0, 2), (1, 2)])</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(4)</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(unconstrained_bridge_augmentation(G))</span>\n<span class=\"sd\">    [(1, 4), (4, 0)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># -----</span>\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Mapping of terms from (Eswaran and Tarjan):</span>\n<span class=\"sd\">        G = G_0 - the input graph</span>\n<span class=\"sd\">        C = G_0&#39; - the bridge condensation of G. (This is a forest of trees)</span>\n<span class=\"sd\">        A1 = A_1 - the edges to connect the forest into a tree</span>\n<span class=\"sd\">        leaf = pendant - a node with degree of 1</span>\n\n<span class=\"sd\">        alpha(v) = maps the node v in G to its meta-node in C</span>\n<span class=\"sd\">        beta(x) = maps the meta-node x in C to any node in the bridge component</span>\n<span class=\"sd\">            of G corresponding to x.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"c1\"># find the 2-edge-connected components of G</span>\n    <span class=\"n\">bridge_ccs</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">bridge_components</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">))</span>\n    <span class=\"c1\"># condense G into an forest C</span>\n    <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">collapse</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">bridge_ccs</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Choose pairs of distinct leaf nodes in each tree. If this is not</span>\n    <span class=\"c1\"># possible then make a pair using the single isolated node in the tree.</span>\n    <span class=\"n\">vset1</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">cc</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mi\">2</span>   <span class=\"c1\"># case1: an isolated node</span>\n        <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">cc</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"k\">else</span>\n        <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">cc</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">2</span><span class=\"p\">]</span>  <span class=\"c1\"># case2: pair of leaf nodes</span>\n        <span class=\"k\">for</span> <span class=\"n\">cc</span> <span class=\"ow\">in</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connected_components</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">vset1</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Use this set to construct edges that connect C into a tree.</span>\n        <span class=\"n\">nodes1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">vs</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">vs</span> <span class=\"ow\">in</span> <span class=\"n\">vset1</span><span class=\"p\">]</span>\n        <span class=\"n\">nodes2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">vs</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">vs</span> <span class=\"ow\">in</span> <span class=\"n\">vset1</span><span class=\"p\">]</span>\n        <span class=\"n\">A1</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">nodes1</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:],</span> <span class=\"n\">nodes2</span><span class=\"p\">))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">A1</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"c1\"># Connect each tree in the forest to construct an arborescence</span>\n    <span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n    <span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">(</span><span class=\"n\">A1</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># If there are only two leaf nodes, we simply connect them.</span>\n    <span class=\"n\">leafs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">d</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">leafs</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">A2</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">leafs</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n        <span class=\"n\">A2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">leafs</span><span class=\"p\">)]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Choose an arbitrary non-leaf root</span>\n        <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">d</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"c1\"># order the leaves of C by (induced directed) preorder</span>\n        <span class=\"n\">v2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">dfs_preorder_nodes</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">T</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"c1\"># connecting first half of the leafs in pre-order to the second</span>\n        <span class=\"c1\"># half will bridge connect the tree with the fewest edges.</span>\n        <span class=\"n\">half</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">ceil</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">2.0</span><span class=\"p\">))</span>\n        <span class=\"n\">A2</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">[:</span><span class=\"n\">half</span><span class=\"p\">],</span> <span class=\"n\">v2</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"n\">half</span><span class=\"p\">:]))</span>\n\n    <span class=\"c1\"># collect the edges used to augment the original forest</span>\n    <span class=\"n\">aug_tree_edges</span> <span class=\"o\">=</span> <span class=\"n\">A1</span> <span class=\"o\">+</span> <span class=\"n\">A2</span>\n\n    <span class=\"c1\"># Construct the mapping (beta) from meta-nodes to regular nodes</span>\n    <span class=\"n\">inverse</span> <span class=\"o\">=</span> <span class=\"n\">defaultdict</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s1\">&#39;mapping&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n    <span class=\"c1\"># sort so we choose minimum degree nodes first</span>\n    <span class=\"n\">inverse</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">mu</span><span class=\"p\">:</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">mapped</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">u</span><span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">),</span> <span class=\"n\">u</span><span class=\"p\">))</span>\n               <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mapped</span> <span class=\"ow\">in</span> <span class=\"n\">inverse</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()}</span>\n\n    <span class=\"c1\"># For each meta-edge, map back to an arbitrary pair in the original graph</span>\n    <span class=\"n\">G2</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span> <span class=\"ow\">in</span> <span class=\"n\">aug_tree_edges</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Find the first available edge that doesn&#39;t exist and return it</span>\n        <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">product</span><span class=\"p\">(</span><span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">mu</span><span class=\"p\">],</span> <span class=\"n\">inverse</span><span class=\"p\">[</span><span class=\"n\">mv</span><span class=\"p\">]):</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">G2</span><span class=\"o\">.</span><span class=\"n\">has_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n                <span class=\"n\">G2</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n                <span class=\"k\">yield</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span>\n                <span class=\"k\">break</span></div>\n\n\n<div class=\"viewcode-block\" id=\"weighted_bridge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.weighted_bridge_augmentation\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">weighted_bridge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Finds an approximate min-weight 2-edge-augmentation of G.</span>\n\n<span class=\"sd\">    This is an implementation of the approximation algorithm detailed in [1]_.</span>\n<span class=\"sd\">    It chooses a set of edges from avail to add to G that renders it</span>\n<span class=\"sd\">    2-edge-connected if such a subset exists.  This is done by finding a</span>\n<span class=\"sd\">    minimum spanning arborescence of a specially constructed metagraph.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    G : NetworkX graph</span>\n\n<span class=\"sd\">    avail : set of 2 or 3 tuples.</span>\n<span class=\"sd\">        candidate edges (with optional weights) to choose from</span>\n\n<span class=\"sd\">    weight : string</span>\n<span class=\"sd\">        key to use to find weights if avail is a set of 3-tuples where the</span>\n<span class=\"sd\">        third item in each tuple is a dictionary.</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    aug_edges (set): subset of avail chosen to augment G</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    Finding a weighted 2-edge-augmentation is NP-hard.</span>\n<span class=\"sd\">    Any edge not in ``avail`` is considered to have a weight of infinity.</span>\n<span class=\"sd\">    The approximation factor is 2 if ``G`` is connected and 3 if it is not.</span>\n<span class=\"sd\">    Runs in :math:`O(m + n log(n))` time</span>\n\n<span class=\"sd\">    References</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    .. [1] Khuller, Samir, and Ramakrishna Thurimella. (1993) Approximation</span>\n<span class=\"sd\">        algorithms for graph augmentation.</span>\n<span class=\"sd\">        http://www.sciencedirect.com/science/article/pii/S0196677483710102</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>\n<span class=\"sd\">    &gt;&gt;&gt; # When the weights are equal, (1, 4) is the best</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 4, 1), (1, 3, 1), (2, 4, 1)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail))</span>\n<span class=\"sd\">    [(1, 4)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; # Giving (1, 4) a high weight makes the two edge solution the best.</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 4, 1000), (1, 3, 1), (2, 4, 1)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail))</span>\n<span class=\"sd\">    [(1, 3), (2, 4)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; #------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(5)</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 1)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail=avail))</span>\n<span class=\"sd\">    [(1, 5), (4, 5)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = [(1, 5, 11), (2, 5, 10), (4, 3, 1), (4, 5, 51)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(weighted_bridge_augmentation(G, avail=avail))</span>\n<span class=\"sd\">    [(1, 5), (2, 5), (4, 5)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">weight</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">weight</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;weight&#39;</span>\n\n    <span class=\"c1\"># If input G is not connected the approximation factor increases to 3</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">is_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">):</span>\n        <span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"n\">connectors</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">one_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">))</span>\n        <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">(</span><span class=\"n\">connectors</span><span class=\"p\">)</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">connectors</span><span class=\"p\">:</span>\n            <span class=\"k\">yield</span> <span class=\"n\">edge</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">connectors</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">G</span>\n\n    <span class=\"c1\"># assert nx.is_connected(H), &#39;should have been one-connected&#39;</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">has_bridges</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span><span class=\"s1\">&#39;no augmentation possible&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"n\">_unpack_available_edges</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"o\">=</span><span class=\"n\">H</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Collapse input into a metagraph. Meta nodes are bridge-ccs</span>\n    <span class=\"n\">bridge_ccs</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">connectivity</span><span class=\"o\">.</span><span class=\"n\">bridge_components</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">)</span>\n    <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">collapse</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">bridge_ccs</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Use the meta graph to shrink avail to a small feasible subset</span>\n    <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s1\">&#39;mapping&#39;</span><span class=\"p\">]</span>\n    <span class=\"c1\"># Choose the minimum weight feasible edge in each group</span>\n    <span class=\"n\">meta_to_wuv</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">):</span> <span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">uv</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"n\">uv</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"ow\">in</span> <span class=\"n\">_lightest_meta_edges</span><span class=\"p\">(</span><span class=\"n\">mapping</span><span class=\"p\">,</span> <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Mapping of terms from (Khuller and Thurimella):</span>\n<span class=\"sd\">        C         : G_0 = (V, E^0)</span>\n<span class=\"sd\">           This is the metagraph where each node is a 2-edge-cc in G.</span>\n<span class=\"sd\">           The edges in C represent bridges in the original graph.</span>\n<span class=\"sd\">        (mu, mv)  : E - E^0  # they group both avail and given edges in E</span>\n<span class=\"sd\">        T         : \\Gamma</span>\n<span class=\"sd\">        D         : G^D = (V, E_D)</span>\n\n<span class=\"sd\">        The paper uses ancestor because children point to parents, which is</span>\n<span class=\"sd\">        contrary to networkx standards.  So, we actually need to run</span>\n<span class=\"sd\">        nx.least_common_ancestor on the reversed Tree.</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Pick an arbitrary leaf from C as the root</span>\n    <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Root C into a tree TR by directing all edges away from the root</span>\n    <span class=\"c1\"># Note in their paper T directs edges towards the root</span>\n    <span class=\"n\">TR</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">dfs_tree</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Add to D the directed edges of T and set their weight to zero</span>\n    <span class=\"c1\"># This indicates that it costs nothing to use edges that were given.</span>\n    <span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">reverse</span><span class=\"p\">(</span><span class=\"n\">TR</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n\n    <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">set_edge_attributes</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;weight&#39;</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># The LCA of mu and mv in T is the shared ancestor of mu and mv that is</span>\n    <span class=\"c1\"># located farthest from the root.</span>\n    <span class=\"k\">if</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">__version__</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">&#39;1&#39;</span><span class=\"p\">):</span>\n        <span class=\"n\">lca_gen</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n            <span class=\"p\">((</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"n\">_lowest_common_anscestor</span><span class=\"p\">(</span><span class=\"n\">TR</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">))</span>\n            <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span> <span class=\"ow\">in</span> <span class=\"n\">meta_to_wuv</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>\n        <span class=\"p\">]</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">lca_gen</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">tree_all_pairs_lowest_common_ancestor</span><span class=\"p\">(</span>\n            <span class=\"n\">TR</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"o\">=</span><span class=\"n\">root</span><span class=\"p\">,</span> <span class=\"n\">pairs</span><span class=\"o\">=</span><span class=\"n\">meta_to_wuv</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">),</span> <span class=\"n\">lca</span> <span class=\"ow\">in</span> <span class=\"n\">lca_gen</span><span class=\"p\">:</span>\n        <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">uv</span> <span class=\"o\">=</span> <span class=\"n\">meta_to_wuv</span><span class=\"p\">[(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">)]</span>\n        <span class=\"k\">if</span> <span class=\"n\">lca</span> <span class=\"o\">==</span> <span class=\"n\">mu</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If u is an ancestor of v in TR, then add edge u-&gt;v to D</span>\n            <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">lca</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">generator</span><span class=\"o\">=</span><span class=\"n\">uv</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">lca</span> <span class=\"o\">==</span> <span class=\"n\">mv</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If v is an ancestor of u in TR, then add edge v-&gt;u to D</span>\n            <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">lca</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">generator</span><span class=\"o\">=</span><span class=\"n\">uv</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># If neither u nor v is a ancestor of the other in TR</span>\n            <span class=\"c1\"># let t = lca(TR, u, v) and add edges t-&gt;u and t-&gt;v</span>\n            <span class=\"c1\"># Track the original edge that GENERATED these edges.</span>\n            <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">lca</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">generator</span><span class=\"o\">=</span><span class=\"n\">uv</span><span class=\"p\">)</span>\n            <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">lca</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">generator</span><span class=\"o\">=</span><span class=\"n\">uv</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Then compute a minimum rooted branching</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Note the original edges must be directed towards to root for the</span>\n        <span class=\"c1\"># branching to give us a bridge-augmentation.</span>\n        <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">_minimum_rooted_branching</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXException</span><span class=\"p\">:</span>\n        <span class=\"c1\"># If there is no branching then augmentation is not possible</span>\n        <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span><span class=\"s1\">&#39;no 2-edge-augmentation possible&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># For each edge e, in the branching that did not belong to the directed</span>\n    <span class=\"c1\"># tree T, add the correponding edge that **GENERATED** it (this is not</span>\n    <span class=\"c1\"># necesarilly e itself!)</span>\n\n    <span class=\"c1\"># ensure the third case does not generate edges twice</span>\n    <span class=\"n\">bridge_connectors</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span> <span class=\"ow\">in</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">():</span>\n        <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">get_edge_data</span><span class=\"p\">(</span><span class=\"n\">mu</span><span class=\"p\">,</span> <span class=\"n\">mv</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"s1\">&#39;generator&#39;</span> <span class=\"ow\">in</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Add the avail edge that generated the branching edge.</span>\n            <span class=\"n\">edge</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"s1\">&#39;generator&#39;</span><span class=\"p\">]</span>\n            <span class=\"n\">bridge_connectors</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">edge</span><span class=\"p\">)</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">bridge_connectors</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">edge</span></div>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_minimum_rooted_branching</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Computes minimum rooted branching (aka rooted arborescence)</span>\n\n<span class=\"sd\">    Before the branching can be computed, the directed graph must be rooted by</span>\n<span class=\"sd\">    removing the predecessors of root.</span>\n\n<span class=\"sd\">    A branching / arborescence of rooted graph G is a subgraph that contains a</span>\n<span class=\"sd\">    directed path from the root to every other vertex. It is the directed</span>\n<span class=\"sd\">    analog of the minimum spanning tree problem.</span>\n\n<span class=\"sd\">    References</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    [1] Khuller, Samir (2002) Advanced Algorithms Lecture 24 Notes.</span>\n<span class=\"sd\">    https://www.cs.umd.edu/class/spring2011/cmsc651/lec07.pdf</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">rooted</span> <span class=\"o\">=</span> <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n    <span class=\"c1\"># root the graph by removing all predecessors to `root`.</span>\n    <span class=\"n\">rooted</span><span class=\"o\">.</span><span class=\"n\">remove_edges_from</span><span class=\"p\">([(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">u</span> <span class=\"ow\">in</span> <span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">predecessors</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"p\">)])</span>\n    <span class=\"c1\"># Then compute the branching / arborescence.</span>\n    <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">minimum_spanning_arborescence</span><span class=\"p\">(</span><span class=\"n\">rooted</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">A</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_lowest_common_anscestor</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Find a least common anscestors</span>\n    <span class=\"n\">v_branch</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">ancestors</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">union</span><span class=\"p\">({</span><span class=\"n\">v</span><span class=\"p\">})</span>\n    <span class=\"n\">u_branch</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">ancestors</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">union</span><span class=\"p\">({</span><span class=\"n\">u</span><span class=\"p\">})</span>\n    <span class=\"n\">common</span> <span class=\"o\">=</span> <span class=\"n\">v_branch</span> <span class=\"o\">&amp;</span> <span class=\"n\">u_branch</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">common</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">lca</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">lca</span> <span class=\"o\">=</span> <span class=\"nb\">max</span><span class=\"p\">(</span>\n            <span class=\"p\">(</span><span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">shortest_path_length</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">),</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">common</span>\n        <span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">lca</span>\n\n\n<div class=\"viewcode-block\" id=\"collapse\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.collapse\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">collapse</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">grouped_nodes</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Collapses each group of nodes into a single node.</span>\n\n<span class=\"sd\">    This is similar to condensation, but works on undirected graphs.</span>\n\n<span class=\"sd\">    Parameters</span>\n<span class=\"sd\">    ----------</span>\n<span class=\"sd\">    G : NetworkX Graph</span>\n<span class=\"sd\">       A directed graph.</span>\n\n<span class=\"sd\">    grouped_nodes:  list or generator</span>\n<span class=\"sd\">       Grouping of nodes to collapse. The grouping must be disjoint.</span>\n<span class=\"sd\">       If grouped_nodes are strongly_connected_components then this is</span>\n<span class=\"sd\">       equivalent to condensation.</span>\n\n<span class=\"sd\">    Returns</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    C : NetworkX Graph</span>\n<span class=\"sd\">       The collapsed graph C of G with respect to the node grouping.  The node</span>\n<span class=\"sd\">       labels are integers corresponding to the index of the component in the</span>\n<span class=\"sd\">       list of strongly connected components of G.  C has a graph attribute</span>\n<span class=\"sd\">       named &#39;mapping&#39; with a dictionary mapping the original nodes to the</span>\n<span class=\"sd\">       nodes in C to which they belong.  Each node in C also has a node</span>\n<span class=\"sd\">       attribute &#39;members&#39; with the set of original nodes in G that form the</span>\n<span class=\"sd\">       group that the node in C represents.</span>\n\n<span class=\"sd\">    Examples</span>\n<span class=\"sd\">    --------</span>\n<span class=\"sd\">    &gt;&gt;&gt; # Collapses a graph using disjoint groups, but not necesarilly connected</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.Graph([(1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 6), (5, 7)])</span>\n<span class=\"sd\">    &gt;&gt;&gt; G.add_node(&#39;A&#39;)</span>\n<span class=\"sd\">    &gt;&gt;&gt; grouped_nodes = [{0, 1, 2, 3}, {5, 6, 7}]</span>\n<span class=\"sd\">    &gt;&gt;&gt; C = collapse(G, grouped_nodes)</span>\n<span class=\"sd\">    &gt;&gt;&gt; members = nx.get_node_attributes(C, &#39;members&#39;)</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(members.keys())</span>\n<span class=\"sd\">    [0, 1, 2, 3]</span>\n<span class=\"sd\">    &gt;&gt;&gt; member_values = set(map(frozenset, members.values()))</span>\n<span class=\"sd\">    &gt;&gt;&gt; assert {0, 1, 2, 3} in member_values</span>\n<span class=\"sd\">    &gt;&gt;&gt; assert {4} in member_values</span>\n<span class=\"sd\">    &gt;&gt;&gt; assert {5, 6, 7} in member_values</span>\n<span class=\"sd\">    &gt;&gt;&gt; assert {&#39;A&#39;} in member_values</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">members</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"p\">()</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>  <span class=\"c1\"># required if G is empty</span>\n    <span class=\"n\">remaining</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">())</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">grouped_nodes</span><span class=\"p\">):</span>\n        <span class=\"n\">group</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n        <span class=\"k\">assert</span> <span class=\"n\">remaining</span><span class=\"o\">.</span><span class=\"n\">issuperset</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">),</span> <span class=\"p\">(</span>\n            <span class=\"s1\">&#39;grouped nodes must exist in G and be disjoint&#39;</span><span class=\"p\">)</span>\n        <span class=\"n\">remaining</span><span class=\"o\">.</span><span class=\"n\">difference_update</span><span class=\"p\">(</span><span class=\"n\">group</span><span class=\"p\">)</span>\n        <span class=\"n\">members</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">group</span>\n        <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">((</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">group</span><span class=\"p\">)</span>\n    <span class=\"c1\"># remaining nodes are in their own group</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">node</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">remaining</span><span class=\"p\">,</span> <span class=\"n\">start</span><span class=\"o\">=</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"n\">group</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">([</span><span class=\"n\">node</span><span class=\"p\">])</span>\n        <span class=\"n\">members</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">group</span>\n        <span class=\"n\">mapping</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">((</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">group</span><span class=\"p\">)</span>\n    <span class=\"n\">number_of_groups</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">add_nodes_from</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">number_of_groups</span><span class=\"p\">))</span>\n    <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">((</span><span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">],</span> <span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">()</span>\n                     <span class=\"k\">if</span> <span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"n\">mapping</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">])</span>\n    <span class=\"c1\"># Add a list of members (ie original nodes) to each node (ie scc) in C.</span>\n    <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">set_node_attributes</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;members&#39;</span><span class=\"p\">,</span> <span class=\"n\">values</span><span class=\"o\">=</span><span class=\"n\">members</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Add mapping dict as graph attribute</span>\n    <span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">graph</span><span class=\"p\">[</span><span class=\"s1\">&#39;mapping&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">mapping</span>\n    <span class=\"k\">return</span> <span class=\"n\">C</span></div>\n\n\n<div class=\"viewcode-block\" id=\"complement_edges\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.complement_edges\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">complement_edges</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Returns only the edges in the complement of G</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4))</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(complement_edges(G))</span>\n<span class=\"sd\">    [(1, 3), (1, 4), (2, 4)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4), nx.DiGraph())</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(complement_edges(G))</span>\n<span class=\"sd\">    [(1, 3), (1, 4), (2, 1), (2, 4), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.complete_graph(1000)</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(complement_edges(G))</span>\n<span class=\"sd\">    []</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"k\">if</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">is_directed</span><span class=\"p\">():</span>\n        <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">combinations</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">(),</span> <span class=\"mi\">2</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">adj</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">]:</span>\n                <span class=\"k\">yield</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">u</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">adj</span><span class=\"p\">[</span><span class=\"n\">v</span><span class=\"p\">]:</span>\n                <span class=\"k\">yield</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"ow\">in</span> <span class=\"n\">it</span><span class=\"o\">.</span><span class=\"n\">combinations</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">(),</span> <span class=\"mi\">2</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">adj</span><span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">]:</span>\n                <span class=\"k\">yield</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span></div>\n\n\n<span class=\"k\">if</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">version_info</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">compat_shuffle</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">,</span> <span class=\"nb\">input</span><span class=\"p\">):</span>\n        <span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">        python2 workaround so shuffle works the same as python3</span>\n\n<span class=\"sd\">        References</span>\n<span class=\"sd\">        ----------</span>\n<span class=\"sd\">        https://stackoverflow.com/questions/38943038/diff-shuffle-py2-py3</span>\n<span class=\"sd\">        &quot;&quot;&quot;</span>\n        <span class=\"k\">def</span> <span class=\"nf\">_randbelow</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n            <span class=\"s2\">&quot;Return a random int in the range [0,n). Raises ValueError if n==0.&quot;</span>\n            <span class=\"n\">getrandbits</span> <span class=\"o\">=</span> <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">getrandbits</span>\n            <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">bit_length</span><span class=\"p\">()</span>  <span class=\"c1\"># don&#39;t use (n-1) here because n can be 1</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">getrandbits</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>  <span class=\"c1\"># 0 &lt;= r &lt; 2**k</span>\n            <span class=\"k\">while</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">n</span><span class=\"p\">:</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">getrandbits</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">r</span>\n\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"c1\"># pick an element in input[:i+1] with which to exchange input[i]</span>\n            <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">_randbelow</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"nb\">input</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"nb\">input</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">input</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">],</span> <span class=\"nb\">input</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n<div class=\"viewcode-block\" id=\"compat_shuffle\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.compat_shuffle\">[docs]</a>    <span class=\"k\">def</span> <span class=\"nf\">compat_shuffle</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">,</span> <span class=\"nb\">input</span><span class=\"p\">):</span>\n        <span class=\"n\">rng</span><span class=\"o\">.</span><span class=\"n\">shuffle</span><span class=\"p\">(</span><span class=\"nb\">input</span><span class=\"p\">)</span></div>\n\n\n<div class=\"viewcode-block\" id=\"greedy_k_edge_augmentation\"><a class=\"viewcode-back\" href=\"../../../../../ibeis.algo.graph/#ibeis.algo.graph.nx_edge_augmentation.greedy_k_edge_augmentation\">[docs]</a><span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;multigraph&#39;</span><span class=\"p\">)</span>\n<span class=\"nd\">@not_implemented_for</span><span class=\"p\">(</span><span class=\"s1\">&#39;directed&#39;</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">greedy_k_edge_augmentation</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">avail</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">&quot;&quot;&quot;Greedy algorithm for finding a k-edge-augmentation</span>\n\n<span class=\"sd\">    Notes</span>\n<span class=\"sd\">    -----</span>\n<span class=\"sd\">    The algorithm is simple. Edges are incrementally added between parts of the</span>\n<span class=\"sd\">    graph that are not yet locally k-edge-connected. Then edges are from the</span>\n<span class=\"sd\">    augmenting set are pruned as long as local-edge-connectivity is not broken.</span>\n\n<span class=\"sd\">    This algorithm is greedy and does not provide optimiality gaurentees. It</span>\n<span class=\"sd\">    exists only to provide :func:`k_edge_augmentation` with the ability to</span>\n<span class=\"sd\">    generate a feasible solution for arbitrary k.</span>\n\n<span class=\"sd\">    Example</span>\n<span class=\"sd\">    -------</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=2))</span>\n<span class=\"sd\">    [(1, 7)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=1, avail=[]))</span>\n<span class=\"sd\">    []</span>\n<span class=\"sd\">    &gt;&gt;&gt; G = nx.path_graph((1, 2, 3, 4, 5, 6, 7))</span>\n<span class=\"sd\">    &gt;&gt;&gt; avail = {(u, v): 1 for (u, v) in complement_edges(G)}</span>\n<span class=\"sd\">    &gt;&gt;&gt; # randomized pruning process can produce different solutions</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=2))</span>\n<span class=\"sd\">    [(1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 4), (2, 6), (3, 7), (5, 7)]</span>\n<span class=\"sd\">    &gt;&gt;&gt; sorted(greedy_k_edge_augmentation(G, k=4, avail=avail, seed=3))</span>\n<span class=\"sd\">    [(1, 3), (1, 5), (1, 6), (2, 4), (2, 6), (3, 7), (4, 7), (5, 7)]</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"c1\"># Result set</span>\n    <span class=\"n\">aug_edges</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n    <span class=\"n\">done</span> <span class=\"o\">=</span> <span class=\"n\">is_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">done</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">StopIteration</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span> <span class=\"n\">avail</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"c1\"># all edges are available</span>\n        <span class=\"n\">avail_uv</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">complement_edges</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">))</span>\n        <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">avail_uv</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Get the unique set of unweighted edges</span>\n        <span class=\"n\">avail_uv</span><span class=\"p\">,</span> <span class=\"n\">avail_w</span> <span class=\"o\">=</span> <span class=\"n\">_unpack_available_edges</span><span class=\"p\">(</span><span class=\"n\">avail</span><span class=\"p\">,</span> <span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"o\">=</span><span class=\"n\">G</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Greedy: order lightest edges. Use degree sum to tie-break</span>\n    <span class=\"n\">tiebreaker</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">,</span> <span class=\"n\">uv</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">uv</span> <span class=\"ow\">in</span> <span class=\"n\">avail_uv</span><span class=\"p\">]</span>\n    <span class=\"n\">avail_wduv</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">avail_w</span><span class=\"p\">,</span> <span class=\"n\">tiebreaker</span><span class=\"p\">,</span> <span class=\"n\">avail_uv</span><span class=\"p\">))</span>\n    <span class=\"n\">avail_uv</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">uv</span> <span class=\"k\">for</span> <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">uv</span> <span class=\"ow\">in</span> <span class=\"n\">avail_wduv</span><span class=\"p\">]</span>\n    <span class=\"c1\"># avail_w = [w for w, uv in avail_wuv]</span>\n\n    <span class=\"c1\"># Incrementally add edges in until we are k-connected</span>\n    <span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">avail_uv</span><span class=\"p\">:</span>\n        <span class=\"n\">done</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">is_locally_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Only add edges in parts that are not yet locally k-edge-connected</span>\n            <span class=\"n\">aug_edges</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">))</span>\n            <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Did adding this edge help?</span>\n            <span class=\"k\">if</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span> <span class=\"ow\">and</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"p\">:</span>\n                <span class=\"n\">done</span> <span class=\"o\">=</span> <span class=\"n\">is_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">done</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n\n    <span class=\"c1\"># Check for feasibility</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">done</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">NetworkXUnfeasible</span><span class=\"p\">(</span>\n            <span class=\"s1\">&#39;not able to k-edge-connect with available edges&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Randomized attempt to reduce the size of the solution</span>\n    <span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">Random</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"c1\"># rng.shuffle(aug_edges)</span>\n    <span class=\"n\">compat_shuffle</span><span class=\"p\">(</span><span class=\"n\">rng</span><span class=\"p\">,</span> <span class=\"n\">aug_edges</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">aug_edges</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Dont remove if we know it would break connectivity</span>\n        <span class=\"k\">if</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span> <span class=\"ow\">or</span> <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">degree</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span><span class=\"p\">:</span>\n            <span class=\"k\">continue</span>\n        <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n        <span class=\"n\">aug_edges</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">((</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">))</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">is_k_edge_connected</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">):</span>\n            <span class=\"c1\"># If removing this edge breaks feasibility, undo</span>\n            <span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n            <span class=\"n\">aug_edges</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">((</span><span class=\"n\">u</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Generate results</span>\n    <span class=\"k\">for</span> <span class=\"n\">edge</span> <span class=\"ow\">in</span> <span class=\"n\">aug_edges</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">edge</span></div>\n</pre></div>", "current_page_name": "_modules/ibeis/algo/graph/nx_edge_augmentation", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}